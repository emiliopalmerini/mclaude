// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addSessionTag = `-- name: AddSessionTag :exec

INSERT INTO session_tags (session_id, tag_name) VALUES (?, ?)
`

type AddSessionTagParams struct {
	SessionID string `json:"session_id"`
	TagName   string `json:"tag_name"`
}

// ============================================================================
// TAG & QUALITY DATA QUERIES
// ============================================================================
func (q *Queries) AddSessionTag(ctx context.Context, arg AddSessionTagParams) error {
	_, err := q.db.ExecContext(ctx, addSessionTag, arg.SessionID, arg.TagName)
	return err
}

const countLimitEvents = `-- name: CountLimitEvents :one
SELECT COUNT(*) as count FROM limit_events
`

func (q *Queries) CountLimitEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLimitEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSessions = `-- name: CountSessions :one
SELECT COUNT(*) as count FROM sessions
`

func (q *Queries) CountSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSessionsFiltered = `-- name: CountSessionsFiltered :one
SELECT COUNT(*) as count FROM sessions
WHERE
    (?1 IS NULL OR hostname = ?1)
    AND (?2 IS NULL OR git_branch = ?2)
    AND (?3 IS NULL OR model = ?3)
    AND (?4 IS NULL OR timestamp >= ?4)
    AND (?5 IS NULL OR timestamp <= ?5)
`

type CountSessionsFilteredParams struct {
	Hostname  interface{} `json:"hostname"`
	GitBranch interface{} `json:"git_branch"`
	Model     interface{} `json:"model"`
	StartDate interface{} `json:"start_date"`
	EndDate   interface{} `json:"end_date"`
}

func (q *Queries) CountSessionsFiltered(ctx context.Context, arg CountSessionsFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessionsFiltered,
		arg.Hostname,
		arg.GitBranch,
		arg.Model,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllTags = `-- name: GetAllTags :many
SELECT name, category, color FROM tags ORDER BY category, name
`

func (q *Queries) GetAllTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.Name, &i.Category, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCacheMetrics = `-- name: GetCacheMetrics :one
SELECT
    COALESCE(SUM(cache_read_tokens), 0) as cache_read,
    COALESCE(SUM(cache_write_tokens), 0) as cache_write,
    COALESCE(SUM(input_tokens + output_tokens), 0) as total_tokens
FROM sessions
WHERE timestamp >= datetime('now', ? || ' days')
`

type GetCacheMetricsRow struct {
	CacheRead   interface{} `json:"cache_read"`
	CacheWrite  interface{} `json:"cache_write"`
	TotalTokens interface{} `json:"total_tokens"`
}

func (q *Queries) GetCacheMetrics(ctx context.Context, dollar_1 sql.NullString) (GetCacheMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getCacheMetrics, dollar_1)
	var i GetCacheMetricsRow
	err := row.Scan(&i.CacheRead, &i.CacheWrite, &i.TotalTokens)
	return i, err
}

const getCacheMetricsDaily = `-- name: GetCacheMetricsDaily :many
SELECT
    date(timestamp) as period,
    COALESCE(SUM(cache_read_tokens), 0) as cache_read,
    COALESCE(SUM(input_tokens + output_tokens), 0) as total_tokens
FROM sessions
WHERE timestamp >= datetime('now', ? || ' days')
GROUP BY date(timestamp)
ORDER BY period ASC
`

type GetCacheMetricsDailyRow struct {
	Period      interface{} `json:"period"`
	CacheRead   interface{} `json:"cache_read"`
	TotalTokens interface{} `json:"total_tokens"`
}

func (q *Queries) GetCacheMetricsDaily(ctx context.Context, dollar_1 sql.NullString) ([]GetCacheMetricsDailyRow, error) {
	rows, err := q.db.QueryContext(ctx, getCacheMetricsDaily, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCacheMetricsDailyRow{}
	for rows.Next() {
		var i GetCacheMetricsDailyRow
		if err := rows.Scan(&i.Period, &i.CacheRead, &i.TotalTokens); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyMetrics = `-- name: GetDailyMetrics :many
SELECT
    date(timestamp) as period,
    COUNT(*) as sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as cost,
    COALESCE(SUM(input_tokens), 0) as input_tokens,
    COALESCE(SUM(output_tokens), 0) as output_tokens,
    COALESCE(SUM(thinking_tokens), 0) as thinking_tokens,
    COALESCE(SUM(cache_read_tokens), 0) as cache_read_tokens,
    COALESCE(SUM(tool_calls), 0) as tool_calls
FROM sessions
WHERE date(timestamp) >= date('now', ? || ' days')
GROUP BY date(timestamp)
ORDER BY period ASC
`

type GetDailyMetricsRow struct {
	Period          interface{} `json:"period"`
	Sessions        int64       `json:"sessions"`
	Cost            interface{} `json:"cost"`
	InputTokens     interface{} `json:"input_tokens"`
	OutputTokens    interface{} `json:"output_tokens"`
	ThinkingTokens  interface{} `json:"thinking_tokens"`
	CacheReadTokens interface{} `json:"cache_read_tokens"`
	ToolCalls       interface{} `json:"tool_calls"`
}

func (q *Queries) GetDailyMetrics(ctx context.Context, dollar_1 sql.NullString) ([]GetDailyMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyMetrics, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyMetricsRow{}
	for rows.Next() {
		var i GetDailyMetricsRow
		if err := rows.Scan(
			&i.Period,
			&i.Sessions,
			&i.Cost,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ThinkingTokens,
			&i.CacheReadTokens,
			&i.ToolCalls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardMetrics = `-- name: GetDashboardMetrics :one
SELECT
    COUNT(*) as total_sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as total_cost_usd,
    COALESCE(SUM(input_tokens), 0) as total_input_tokens,
    COALESCE(SUM(output_tokens), 0) as total_output_tokens,
    COALESCE(SUM(thinking_tokens), 0) as total_thinking_tokens,
    COALESCE(SUM(cache_read_tokens), 0) as total_cache_read_tokens,
    COALESCE(SUM(cache_write_tokens), 0) as total_cache_write_tokens,
    COALESCE(SUM(tool_calls), 0) as total_tool_calls,
    COALESCE(AVG(duration_seconds), 0) as avg_duration_seconds
FROM sessions
`

type GetDashboardMetricsRow struct {
	TotalSessions         int64       `json:"total_sessions"`
	TotalCostUsd          interface{} `json:"total_cost_usd"`
	TotalInputTokens      interface{} `json:"total_input_tokens"`
	TotalOutputTokens     interface{} `json:"total_output_tokens"`
	TotalThinkingTokens   interface{} `json:"total_thinking_tokens"`
	TotalCacheReadTokens  interface{} `json:"total_cache_read_tokens"`
	TotalCacheWriteTokens interface{} `json:"total_cache_write_tokens"`
	TotalToolCalls        interface{} `json:"total_tool_calls"`
	AvgDurationSeconds    interface{} `json:"avg_duration_seconds"`
}

func (q *Queries) GetDashboardMetrics(ctx context.Context) (GetDashboardMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getDashboardMetrics)
	var i GetDashboardMetricsRow
	err := row.Scan(
		&i.TotalSessions,
		&i.TotalCostUsd,
		&i.TotalInputTokens,
		&i.TotalOutputTokens,
		&i.TotalThinkingTokens,
		&i.TotalCacheReadTokens,
		&i.TotalCacheWriteTokens,
		&i.TotalToolCalls,
		&i.AvgDurationSeconds,
	)
	return i, err
}

const getDayOfWeekDistribution = `-- name: GetDayOfWeekDistribution :many
SELECT
    CAST(strftime('%w', timestamp) AS INTEGER) as day_of_week,
    COUNT(*) as sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as cost,
    COALESCE(AVG(user_prompts), 0) as avg_prompts
FROM sessions
WHERE timestamp >= datetime('now', ? || ' days')
GROUP BY strftime('%w', timestamp)
ORDER BY day_of_week ASC
`

type GetDayOfWeekDistributionRow struct {
	DayOfWeek  int64       `json:"day_of_week"`
	Sessions   int64       `json:"sessions"`
	Cost       interface{} `json:"cost"`
	AvgPrompts interface{} `json:"avg_prompts"`
}

func (q *Queries) GetDayOfWeekDistribution(ctx context.Context, dollar_1 sql.NullString) ([]GetDayOfWeekDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getDayOfWeekDistribution, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDayOfWeekDistributionRow{}
	for rows.Next() {
		var i GetDayOfWeekDistributionRow
		if err := rows.Scan(
			&i.DayOfWeek,
			&i.Sessions,
			&i.Cost,
			&i.AvgPrompts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctBranches = `-- name: GetDistinctBranches :many
SELECT DISTINCT git_branch FROM sessions WHERE git_branch != '' ORDER BY git_branch
`

func (q *Queries) GetDistinctBranches(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctBranches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullString{}
	for rows.Next() {
		var git_branch sql.NullString
		if err := rows.Scan(&git_branch); err != nil {
			return nil, err
		}
		items = append(items, git_branch)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctHostnames = `-- name: GetDistinctHostnames :many
SELECT DISTINCT hostname FROM sessions WHERE hostname != '' ORDER BY hostname
`

func (q *Queries) GetDistinctHostnames(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctHostnames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var hostname string
		if err := rows.Scan(&hostname); err != nil {
			return nil, err
		}
		items = append(items, hostname)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctModels = `-- name: GetDistinctModels :many
SELECT DISTINCT model FROM sessions WHERE model != '' ORDER BY model
`

func (q *Queries) GetDistinctModels(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullString{}
	for rows.Next() {
		var model sql.NullString
		if err := rows.Scan(&model); err != nil {
			return nil, err
		}
		items = append(items, model)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEfficiencyMetrics = `-- name: GetEfficiencyMetrics :one
SELECT
    COALESCE(AVG(user_prompts), 0) as avg_prompts_per_session,
    COALESCE(AVG(tool_calls), 0) as avg_tools_per_session,
    COALESCE(AVG(CAST(errors_count AS REAL) / NULLIF(tool_calls, 0)), 0) as error_rate,
    COALESCE(AVG(duration_seconds), 0) as avg_duration
FROM sessions
WHERE timestamp >= datetime('now', ? || ' days')
`

type GetEfficiencyMetricsRow struct {
	AvgPromptsPerSession interface{} `json:"avg_prompts_per_session"`
	AvgToolsPerSession   interface{} `json:"avg_tools_per_session"`
	ErrorRate            interface{} `json:"error_rate"`
	AvgDuration          interface{} `json:"avg_duration"`
}

func (q *Queries) GetEfficiencyMetrics(ctx context.Context, dollar_1 sql.NullString) (GetEfficiencyMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getEfficiencyMetrics, dollar_1)
	var i GetEfficiencyMetricsRow
	err := row.Scan(
		&i.AvgPromptsPerSession,
		&i.AvgToolsPerSession,
		&i.ErrorRate,
		&i.AvgDuration,
	)
	return i, err
}

const getEfficiencyMetricsDaily = `-- name: GetEfficiencyMetricsDaily :many
SELECT
    date(timestamp) as period,
    COALESCE(AVG(user_prompts), 0) as avg_prompts,
    COALESCE(AVG(tool_calls), 0) as avg_tools,
    COUNT(*) as sessions
FROM sessions
WHERE timestamp >= datetime('now', ? || ' days')
GROUP BY date(timestamp)
ORDER BY period ASC
`

type GetEfficiencyMetricsDailyRow struct {
	Period     interface{} `json:"period"`
	AvgPrompts interface{} `json:"avg_prompts"`
	AvgTools   interface{} `json:"avg_tools"`
	Sessions   int64       `json:"sessions"`
}

func (q *Queries) GetEfficiencyMetricsDaily(ctx context.Context, dollar_1 sql.NullString) ([]GetEfficiencyMetricsDailyRow, error) {
	rows, err := q.db.QueryContext(ctx, getEfficiencyMetricsDaily, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEfficiencyMetricsDailyRow{}
	for rows.Next() {
		var i GetEfficiencyMetricsDailyRow
		if err := rows.Scan(
			&i.Period,
			&i.AvgPrompts,
			&i.AvgTools,
			&i.Sessions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHourOfDayDistribution = `-- name: GetHourOfDayDistribution :many
SELECT
    CAST(strftime('%H', timestamp) AS INTEGER) as hour,
    COUNT(*) as sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as cost
FROM sessions
WHERE timestamp >= datetime('now', ? || ' hours')
GROUP BY strftime('%H', timestamp)
ORDER BY hour ASC
`

type GetHourOfDayDistributionRow struct {
	Hour     int64       `json:"hour"`
	Sessions int64       `json:"sessions"`
	Cost     interface{} `json:"cost"`
}

func (q *Queries) GetHourOfDayDistribution(ctx context.Context, dollar_1 sql.NullString) ([]GetHourOfDayDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getHourOfDayDistribution, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHourOfDayDistributionRow{}
	for rows.Next() {
		var i GetHourOfDayDistributionRow
		if err := rows.Scan(&i.Hour, &i.Sessions, &i.Cost); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHourlyMetrics = `-- name: GetHourlyMetrics :many
SELECT
    strftime('%Y-%m-%dT%H:00:00Z', timestamp) as period,
    COUNT(*) as sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as cost,
    COALESCE(SUM(input_tokens), 0) as input_tokens,
    COALESCE(SUM(output_tokens), 0) as output_tokens,
    COALESCE(SUM(thinking_tokens), 0) as thinking_tokens,
    COALESCE(SUM(cache_read_tokens), 0) as cache_read_tokens,
    COALESCE(SUM(tool_calls), 0) as tool_calls
FROM sessions
WHERE timestamp >= datetime('now', ? || ' hours')
GROUP BY strftime('%Y-%m-%dT%H:00:00Z', timestamp)
ORDER BY period ASC
`

type GetHourlyMetricsRow struct {
	Period          interface{} `json:"period"`
	Sessions        int64       `json:"sessions"`
	Cost            interface{} `json:"cost"`
	InputTokens     interface{} `json:"input_tokens"`
	OutputTokens    interface{} `json:"output_tokens"`
	ThinkingTokens  interface{} `json:"thinking_tokens"`
	CacheReadTokens interface{} `json:"cache_read_tokens"`
	ToolCalls       interface{} `json:"tool_calls"`
}

func (q *Queries) GetHourlyMetrics(ctx context.Context, dollar_1 sql.NullString) ([]GetHourlyMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, getHourlyMetrics, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHourlyMetricsRow{}
	for rows.Next() {
		var i GetHourlyMetricsRow
		if err := rows.Scan(
			&i.Period,
			&i.Sessions,
			&i.Cost,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ThinkingTokens,
			&i.CacheReadTokens,
			&i.ToolCalls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastLimitEvent = `-- name: GetLastLimitEvent :one
SELECT timestamp FROM limit_events ORDER BY timestamp DESC LIMIT 1
`

func (q *Queries) GetLastLimitEvent(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLastLimitEvent)
	var timestamp string
	err := row.Scan(&timestamp)
	return timestamp, err
}

const getLimitEventsByType = `-- name: GetLimitEventsByType :many
SELECT
    id, timestamp, limit_type, reset_time,
    sessions_count, input_tokens, output_tokens, thinking_tokens,
    total_cost_usd
FROM limit_events
WHERE limit_type = ?
ORDER BY timestamp DESC
LIMIT ?
`

type GetLimitEventsByTypeParams struct {
	LimitType string `json:"limit_type"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetLimitEventsByType(ctx context.Context, arg GetLimitEventsByTypeParams) ([]LimitEvent, error) {
	rows, err := q.db.QueryContext(ctx, getLimitEventsByType, arg.LimitType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LimitEvent{}
	for rows.Next() {
		var i LimitEvent
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.LimitType,
			&i.ResetTime,
			&i.SessionsCount,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ThinkingTokens,
			&i.TotalCostUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelDistribution = `-- name: GetModelDistribution :many
SELECT
    COALESCE(model, 'Unknown') as model,
    COUNT(*) as sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as cost
FROM sessions
WHERE timestamp >= datetime('now', ? || ' hours')
GROUP BY model
ORDER BY sessions DESC
`

type GetModelDistributionRow struct {
	Model    string      `json:"model"`
	Sessions int64       `json:"sessions"`
	Cost     interface{} `json:"cost"`
}

func (q *Queries) GetModelDistribution(ctx context.Context, dollar_1 sql.NullString) ([]GetModelDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getModelDistribution, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModelDistributionRow{}
	for rows.Next() {
		var i GetModelDistributionRow
		if err := rows.Scan(&i.Model, &i.Sessions, &i.Cost); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelEfficiency = `-- name: GetModelEfficiency :many
SELECT
    COALESCE(model, 'Unknown') as model,
    COUNT(*) as sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as total_cost,
    COALESCE(SUM(input_tokens + output_tokens), 0) as total_tokens,
    CAST(
        CASE
            WHEN SUM(input_tokens + output_tokens) > 0
            THEN COALESCE(SUM(estimated_cost_usd), 0) * 1000000.0 / SUM(input_tokens + output_tokens)
            ELSE 0
        END
    AS INTEGER) as cost_per_million_tokens
FROM sessions
WHERE timestamp >= datetime('now', ? || ' days')
GROUP BY model
ORDER BY total_cost DESC
`

type GetModelEfficiencyRow struct {
	Model                string      `json:"model"`
	Sessions             int64       `json:"sessions"`
	TotalCost            interface{} `json:"total_cost"`
	TotalTokens          interface{} `json:"total_tokens"`
	CostPerMillionTokens int64       `json:"cost_per_million_tokens"`
}

func (q *Queries) GetModelEfficiency(ctx context.Context, dollar_1 sql.NullString) ([]GetModelEfficiencyRow, error) {
	rows, err := q.db.QueryContext(ctx, getModelEfficiency, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetModelEfficiencyRow{}
	for rows.Next() {
		var i GetModelEfficiencyRow
		if err := rows.Scan(
			&i.Model,
			&i.Sessions,
			&i.TotalCost,
			&i.TotalTokens,
			&i.CostPerMillionTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectMetrics = `-- name: GetProjectMetrics :many
SELECT
    COALESCE(working_directory, 'Unknown') as directory,
    COUNT(*) as sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as cost,
    COALESCE(SUM(tool_calls), 0) as tool_calls,
    COALESCE(SUM(user_prompts), 0) as prompts,
    COALESCE(AVG(duration_seconds), 0) as avg_duration
FROM sessions
WHERE working_directory IS NOT NULL AND working_directory != ''
  AND timestamp >= datetime('now', ? || ' days')
GROUP BY working_directory
ORDER BY cost DESC
`

type GetProjectMetricsRow struct {
	Directory   string      `json:"directory"`
	Sessions    int64       `json:"sessions"`
	Cost        interface{} `json:"cost"`
	ToolCalls   interface{} `json:"tool_calls"`
	Prompts     interface{} `json:"prompts"`
	AvgDuration interface{} `json:"avg_duration"`
}

func (q *Queries) GetProjectMetrics(ctx context.Context, dollar_1 sql.NullString) ([]GetProjectMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProjectMetrics, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectMetricsRow{}
	for rows.Next() {
		var i GetProjectMetricsRow
		if err := rows.Scan(
			&i.Directory,
			&i.Sessions,
			&i.Cost,
			&i.ToolCalls,
			&i.Prompts,
			&i.AvgDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLimitEvents = `-- name: GetRecentLimitEvents :many
SELECT
    id, timestamp, limit_type, reset_time,
    sessions_count, input_tokens, output_tokens, thinking_tokens,
    total_cost_usd
FROM limit_events
WHERE timestamp >= datetime('now', ? || ' days')
ORDER BY timestamp DESC
`

func (q *Queries) GetRecentLimitEvents(ctx context.Context, dollar_1 sql.NullString) ([]LimitEvent, error) {
	rows, err := q.db.QueryContext(ctx, getRecentLimitEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LimitEvent{}
	for rows.Next() {
		var i LimitEvent
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.LimitType,
			&i.ResetTime,
			&i.SessionsCount,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ThinkingTokens,
			&i.TotalCostUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, session_id, instance_id, hostname, timestamp, exit_reason, permission_mode, working_directory, git_branch, claude_version, duration_seconds, user_prompts, assistant_responses, tool_calls, tools_breakdown, files_accessed, files_modified, input_tokens, output_tokens, thinking_tokens, cache_read_tokens, cache_write_tokens, estimated_cost_usd, errors_count, model, summary, rating, prompt_specificity, task_completion, code_confidence, notes, limit_message FROM sessions WHERE session_id = ?
`

func (q *Queries) GetSessionByID(ctx context.Context, sessionID string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, sessionID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.InstanceID,
		&i.Hostname,
		&i.Timestamp,
		&i.ExitReason,
		&i.PermissionMode,
		&i.WorkingDirectory,
		&i.GitBranch,
		&i.ClaudeVersion,
		&i.DurationSeconds,
		&i.UserPrompts,
		&i.AssistantResponses,
		&i.ToolCalls,
		&i.ToolsBreakdown,
		&i.FilesAccessed,
		&i.FilesModified,
		&i.InputTokens,
		&i.OutputTokens,
		&i.ThinkingTokens,
		&i.CacheReadTokens,
		&i.CacheWriteTokens,
		&i.EstimatedCostUsd,
		&i.ErrorsCount,
		&i.Model,
		&i.Summary,
		&i.Rating,
		&i.PromptSpecificity,
		&i.TaskCompletion,
		&i.CodeConfidence,
		&i.Notes,
		&i.LimitMessage,
	)
	return i, err
}

const getSessionTags = `-- name: GetSessionTags :many
SELECT t.name, t.category, t.color
FROM tags t
JOIN session_tags st ON t.name = st.tag_name
WHERE st.session_id = ?
ORDER BY t.category, t.name
`

func (q *Queries) GetSessionTags(ctx context.Context, sessionID string) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTags, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.Name, &i.Category, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsWithLimitMessage = `-- name: GetSessionsWithLimitMessage :many
SELECT
    id, session_id, timestamp, limit_message,
    input_tokens, output_tokens, thinking_tokens, estimated_cost_usd
FROM sessions
WHERE limit_message IS NOT NULL AND limit_message != ''
ORDER BY timestamp DESC
LIMIT ?
`

type GetSessionsWithLimitMessageRow struct {
	ID               int64           `json:"id"`
	SessionID        string          `json:"session_id"`
	Timestamp        string          `json:"timestamp"`
	LimitMessage     sql.NullString  `json:"limit_message"`
	InputTokens      sql.NullInt64   `json:"input_tokens"`
	OutputTokens     sql.NullInt64   `json:"output_tokens"`
	ThinkingTokens   sql.NullInt64   `json:"thinking_tokens"`
	EstimatedCostUsd sql.NullFloat64 `json:"estimated_cost_usd"`
}

func (q *Queries) GetSessionsWithLimitMessage(ctx context.Context, limit int64) ([]GetSessionsWithLimitMessageRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionsWithLimitMessage, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionsWithLimitMessageRow{}
	for rows.Next() {
		var i GetSessionsWithLimitMessageRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Timestamp,
			&i.LimitMessage,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ThinkingTokens,
			&i.EstimatedCostUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodayMetrics = `-- name: GetTodayMetrics :one
SELECT
    COUNT(*) as sessions_today,
    COALESCE(SUM(estimated_cost_usd), 0) as cost_today,
    COALESCE(SUM(input_tokens), 0) as input_tokens_today,
    COALESCE(SUM(output_tokens), 0) as output_tokens_today,
    COALESCE(SUM(thinking_tokens), 0) as thinking_tokens_today
FROM sessions
WHERE date(timestamp) = date('now')
`

type GetTodayMetricsRow struct {
	SessionsToday       int64       `json:"sessions_today"`
	CostToday           interface{} `json:"cost_today"`
	InputTokensToday    interface{} `json:"input_tokens_today"`
	OutputTokensToday   interface{} `json:"output_tokens_today"`
	ThinkingTokensToday interface{} `json:"thinking_tokens_today"`
}

func (q *Queries) GetTodayMetrics(ctx context.Context) (GetTodayMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getTodayMetrics)
	var i GetTodayMetricsRow
	err := row.Scan(
		&i.SessionsToday,
		&i.CostToday,
		&i.InputTokensToday,
		&i.OutputTokensToday,
		&i.ThinkingTokensToday,
	)
	return i, err
}

const getToolsBreakdownAll = `-- name: GetToolsBreakdownAll :many

SELECT tools_breakdown
FROM sessions
WHERE tools_breakdown IS NOT NULL AND tools_breakdown != ''
  AND timestamp >= datetime('now', ? || ' days')
`

// ============================================================================
// PRODUCTIVITY & COST ANALYTICS QUERIES
// ============================================================================
func (q *Queries) GetToolsBreakdownAll(ctx context.Context, dollar_1 sql.NullString) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getToolsBreakdownAll, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullString{}
	for rows.Next() {
		var tools_breakdown sql.NullString
		if err := rows.Scan(&tools_breakdown); err != nil {
			return nil, err
		}
		items = append(items, tools_breakdown)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopProject = `-- name: GetTopProject :one
SELECT COALESCE(working_directory, 'Unknown') as directory, COUNT(*) as sessions
FROM sessions
WHERE working_directory IS NOT NULL AND working_directory != ''
  AND timestamp >= datetime('now', '-7 days')
GROUP BY working_directory
ORDER BY sessions DESC
LIMIT 1
`

type GetTopProjectRow struct {
	Directory string `json:"directory"`
	Sessions  int64  `json:"sessions"`
}

func (q *Queries) GetTopProject(ctx context.Context) (GetTopProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getTopProject)
	var i GetTopProjectRow
	err := row.Scan(&i.Directory, &i.Sessions)
	return i, err
}

const getUsageSinceLastLimit = `-- name: GetUsageSinceLastLimit :one
SELECT
    COUNT(*) as sessions_count,
    COALESCE(SUM(input_tokens), 0) as input_tokens,
    COALESCE(SUM(output_tokens), 0) as output_tokens,
    COALESCE(SUM(thinking_tokens), 0) as thinking_tokens,
    COALESCE(SUM(estimated_cost_usd), 0) as total_cost_usd
FROM sessions
WHERE timestamp > COALESCE(
    (SELECT timestamp FROM limit_events ORDER BY timestamp DESC LIMIT 1),
    '1970-01-01'
)
`

type GetUsageSinceLastLimitRow struct {
	SessionsCount  int64       `json:"sessions_count"`
	InputTokens    interface{} `json:"input_tokens"`
	OutputTokens   interface{} `json:"output_tokens"`
	ThinkingTokens interface{} `json:"thinking_tokens"`
	TotalCostUsd   interface{} `json:"total_cost_usd"`
}

func (q *Queries) GetUsageSinceLastLimit(ctx context.Context) (GetUsageSinceLastLimitRow, error) {
	row := q.db.QueryRowContext(ctx, getUsageSinceLastLimit)
	var i GetUsageSinceLastLimitRow
	err := row.Scan(
		&i.SessionsCount,
		&i.InputTokens,
		&i.OutputTokens,
		&i.ThinkingTokens,
		&i.TotalCostUsd,
	)
	return i, err
}

const getWeekMetrics = `-- name: GetWeekMetrics :one
SELECT
    COUNT(*) as sessions_week,
    COALESCE(SUM(estimated_cost_usd), 0) as cost_week,
    COALESCE(SUM(input_tokens), 0) as input_tokens_week,
    COALESCE(SUM(output_tokens), 0) as output_tokens_week,
    COALESCE(SUM(thinking_tokens), 0) as thinking_tokens_week
FROM sessions
WHERE date(timestamp) >= date('now', '-7 days')
`

type GetWeekMetricsRow struct {
	SessionsWeek       int64       `json:"sessions_week"`
	CostWeek           interface{} `json:"cost_week"`
	InputTokensWeek    interface{} `json:"input_tokens_week"`
	OutputTokensWeek   interface{} `json:"output_tokens_week"`
	ThinkingTokensWeek interface{} `json:"thinking_tokens_week"`
}

func (q *Queries) GetWeekMetrics(ctx context.Context) (GetWeekMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getWeekMetrics)
	var i GetWeekMetricsRow
	err := row.Scan(
		&i.SessionsWeek,
		&i.CostWeek,
		&i.InputTokensWeek,
		&i.OutputTokensWeek,
		&i.ThinkingTokensWeek,
	)
	return i, err
}

const insertLimitEvent = `-- name: InsertLimitEvent :exec

INSERT INTO limit_events (
    timestamp, limit_type, reset_time,
    sessions_count, input_tokens, output_tokens, thinking_tokens,
    total_cost_usd
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertLimitEventParams struct {
	Timestamp      string          `json:"timestamp"`
	LimitType      string          `json:"limit_type"`
	ResetTime      sql.NullString  `json:"reset_time"`
	SessionsCount  sql.NullInt64   `json:"sessions_count"`
	InputTokens    sql.NullInt64   `json:"input_tokens"`
	OutputTokens   sql.NullInt64   `json:"output_tokens"`
	ThinkingTokens sql.NullInt64   `json:"thinking_tokens"`
	TotalCostUsd   sql.NullFloat64 `json:"total_cost_usd"`
}

// ============================================================================
// LIMIT EVENTS QUERIES
// ============================================================================
func (q *Queries) InsertLimitEvent(ctx context.Context, arg InsertLimitEventParams) error {
	_, err := q.db.ExecContext(ctx, insertLimitEvent,
		arg.Timestamp,
		arg.LimitType,
		arg.ResetTime,
		arg.SessionsCount,
		arg.InputTokens,
		arg.OutputTokens,
		arg.ThinkingTokens,
		arg.TotalCostUsd,
	)
	return err
}

const listLimitEvents = `-- name: ListLimitEvents :many
SELECT
    id, timestamp, limit_type, reset_time,
    sessions_count, input_tokens, output_tokens, thinking_tokens,
    total_cost_usd
FROM limit_events
ORDER BY timestamp DESC
LIMIT ? OFFSET ?
`

type ListLimitEventsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListLimitEvents(ctx context.Context, arg ListLimitEventsParams) ([]LimitEvent, error) {
	rows, err := q.db.QueryContext(ctx, listLimitEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LimitEvent{}
	for rows.Next() {
		var i LimitEvent
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.LimitType,
			&i.ResetTime,
			&i.SessionsCount,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ThinkingTokens,
			&i.TotalCostUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT
    id, session_id, hostname, timestamp, exit_reason,
    working_directory, git_branch, duration_seconds,
    user_prompts, tool_calls, estimated_cost_usd, model
FROM sessions
ORDER BY timestamp DESC
LIMIT ? OFFSET ?
`

type ListSessionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListSessionsRow struct {
	ID               int64           `json:"id"`
	SessionID        string          `json:"session_id"`
	Hostname         string          `json:"hostname"`
	Timestamp        string          `json:"timestamp"`
	ExitReason       sql.NullString  `json:"exit_reason"`
	WorkingDirectory sql.NullString  `json:"working_directory"`
	GitBranch        sql.NullString  `json:"git_branch"`
	DurationSeconds  sql.NullInt64   `json:"duration_seconds"`
	UserPrompts      sql.NullInt64   `json:"user_prompts"`
	ToolCalls        sql.NullInt64   `json:"tool_calls"`
	EstimatedCostUsd sql.NullFloat64 `json:"estimated_cost_usd"`
	Model            sql.NullString  `json:"model"`
}

func (q *Queries) ListSessions(ctx context.Context, arg ListSessionsParams) ([]ListSessionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsRow{}
	for rows.Next() {
		var i ListSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Hostname,
			&i.Timestamp,
			&i.ExitReason,
			&i.WorkingDirectory,
			&i.GitBranch,
			&i.DurationSeconds,
			&i.UserPrompts,
			&i.ToolCalls,
			&i.EstimatedCostUsd,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsFiltered = `-- name: ListSessionsFiltered :many
SELECT
    id, session_id, hostname, timestamp, exit_reason,
    working_directory, git_branch, duration_seconds,
    user_prompts, tool_calls, estimated_cost_usd, model
FROM sessions
WHERE
    (?1 IS NULL OR hostname = ?1)
    AND (?2 IS NULL OR git_branch = ?2)
    AND (?3 IS NULL OR model = ?3)
    AND (?4 IS NULL OR timestamp >= ?4)
    AND (?5 IS NULL OR timestamp <= ?5)
ORDER BY timestamp DESC
LIMIT ?7 OFFSET ?6
`

type ListSessionsFilteredParams struct {
	Hostname  interface{} `json:"hostname"`
	GitBranch interface{} `json:"git_branch"`
	Model     interface{} `json:"model"`
	StartDate interface{} `json:"start_date"`
	EndDate   interface{} `json:"end_date"`
	Offset    int64       `json:"offset"`
	Limit     int64       `json:"limit"`
}

type ListSessionsFilteredRow struct {
	ID               int64           `json:"id"`
	SessionID        string          `json:"session_id"`
	Hostname         string          `json:"hostname"`
	Timestamp        string          `json:"timestamp"`
	ExitReason       sql.NullString  `json:"exit_reason"`
	WorkingDirectory sql.NullString  `json:"working_directory"`
	GitBranch        sql.NullString  `json:"git_branch"`
	DurationSeconds  sql.NullInt64   `json:"duration_seconds"`
	UserPrompts      sql.NullInt64   `json:"user_prompts"`
	ToolCalls        sql.NullInt64   `json:"tool_calls"`
	EstimatedCostUsd sql.NullFloat64 `json:"estimated_cost_usd"`
	Model            sql.NullString  `json:"model"`
}

func (q *Queries) ListSessionsFiltered(ctx context.Context, arg ListSessionsFilteredParams) ([]ListSessionsFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsFiltered,
		arg.Hostname,
		arg.GitBranch,
		arg.Model,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsFilteredRow{}
	for rows.Next() {
		var i ListSessionsFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Hostname,
			&i.Timestamp,
			&i.ExitReason,
			&i.WorkingDirectory,
			&i.GitBranch,
			&i.DurationSeconds,
			&i.UserPrompts,
			&i.ToolCalls,
			&i.EstimatedCostUsd,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
