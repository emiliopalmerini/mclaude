// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countSessions = `-- name: CountSessions :one
SELECT COUNT(*) as count FROM sessions
`

func (q *Queries) CountSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDashboardMetrics = `-- name: GetDashboardMetrics :one
SELECT
    COUNT(*) as total_sessions,
    COALESCE(SUM(estimated_cost_usd), 0) as total_cost_usd,
    COALESCE(SUM(input_tokens), 0) as total_input_tokens,
    COALESCE(SUM(output_tokens), 0) as total_output_tokens,
    COALESCE(SUM(thinking_tokens), 0) as total_thinking_tokens,
    COALESCE(SUM(cache_read_tokens), 0) as total_cache_read_tokens,
    COALESCE(SUM(cache_write_tokens), 0) as total_cache_write_tokens,
    COALESCE(SUM(tool_calls), 0) as total_tool_calls,
    COALESCE(AVG(duration_seconds), 0) as avg_duration_seconds
FROM sessions
`

type GetDashboardMetricsRow struct {
	TotalSessions         int64       `json:"total_sessions"`
	TotalCostUsd          interface{} `json:"total_cost_usd"`
	TotalInputTokens      interface{} `json:"total_input_tokens"`
	TotalOutputTokens     interface{} `json:"total_output_tokens"`
	TotalThinkingTokens   interface{} `json:"total_thinking_tokens"`
	TotalCacheReadTokens  interface{} `json:"total_cache_read_tokens"`
	TotalCacheWriteTokens interface{} `json:"total_cache_write_tokens"`
	TotalToolCalls        interface{} `json:"total_tool_calls"`
	AvgDurationSeconds    interface{} `json:"avg_duration_seconds"`
}

func (q *Queries) GetDashboardMetrics(ctx context.Context) (GetDashboardMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getDashboardMetrics)
	var i GetDashboardMetricsRow
	err := row.Scan(
		&i.TotalSessions,
		&i.TotalCostUsd,
		&i.TotalInputTokens,
		&i.TotalOutputTokens,
		&i.TotalThinkingTokens,
		&i.TotalCacheReadTokens,
		&i.TotalCacheWriteTokens,
		&i.TotalToolCalls,
		&i.AvgDurationSeconds,
	)
	return i, err
}

const getDistinctBranches = `-- name: GetDistinctBranches :many
SELECT DISTINCT git_branch FROM sessions WHERE git_branch != '' ORDER BY git_branch
`

func (q *Queries) GetDistinctBranches(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctBranches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullString{}
	for rows.Next() {
		var git_branch sql.NullString
		if err := rows.Scan(&git_branch); err != nil {
			return nil, err
		}
		items = append(items, git_branch)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctHostnames = `-- name: GetDistinctHostnames :many
SELECT DISTINCT hostname FROM sessions WHERE hostname != '' ORDER BY hostname
`

func (q *Queries) GetDistinctHostnames(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctHostnames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var hostname string
		if err := rows.Scan(&hostname); err != nil {
			return nil, err
		}
		items = append(items, hostname)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctModels = `-- name: GetDistinctModels :many
SELECT DISTINCT model FROM sessions WHERE model != '' ORDER BY model
`

func (q *Queries) GetDistinctModels(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullString{}
	for rows.Next() {
		var model sql.NullString
		if err := rows.Scan(&model); err != nil {
			return nil, err
		}
		items = append(items, model)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, session_id, instance_id, hostname, timestamp, exit_reason, permission_mode, working_directory, git_branch, claude_version, duration_seconds, user_prompts, assistant_responses, tool_calls, tools_breakdown, files_accessed, files_modified, input_tokens, output_tokens, thinking_tokens, cache_read_tokens, cache_write_tokens, estimated_cost_usd, errors_count, model, summary FROM sessions WHERE session_id = ?
`

func (q *Queries) GetSessionByID(ctx context.Context, sessionID string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, sessionID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.InstanceID,
		&i.Hostname,
		&i.Timestamp,
		&i.ExitReason,
		&i.PermissionMode,
		&i.WorkingDirectory,
		&i.GitBranch,
		&i.ClaudeVersion,
		&i.DurationSeconds,
		&i.UserPrompts,
		&i.AssistantResponses,
		&i.ToolCalls,
		&i.ToolsBreakdown,
		&i.FilesAccessed,
		&i.FilesModified,
		&i.InputTokens,
		&i.OutputTokens,
		&i.ThinkingTokens,
		&i.CacheReadTokens,
		&i.CacheWriteTokens,
		&i.EstimatedCostUsd,
		&i.ErrorsCount,
		&i.Model,
		&i.Summary,
	)
	return i, err
}

const getTodayMetrics = `-- name: GetTodayMetrics :one
SELECT
    COUNT(*) as sessions_today,
    COALESCE(SUM(estimated_cost_usd), 0) as cost_today
FROM sessions
WHERE date(timestamp) = date('now')
`

type GetTodayMetricsRow struct {
	SessionsToday int64       `json:"sessions_today"`
	CostToday     interface{} `json:"cost_today"`
}

func (q *Queries) GetTodayMetrics(ctx context.Context) (GetTodayMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getTodayMetrics)
	var i GetTodayMetricsRow
	err := row.Scan(&i.SessionsToday, &i.CostToday)
	return i, err
}

const getWeekMetrics = `-- name: GetWeekMetrics :one
SELECT
    COUNT(*) as sessions_week,
    COALESCE(SUM(estimated_cost_usd), 0) as cost_week
FROM sessions
WHERE date(timestamp) >= date('now', '-7 days')
`

type GetWeekMetricsRow struct {
	SessionsWeek int64       `json:"sessions_week"`
	CostWeek     interface{} `json:"cost_week"`
}

func (q *Queries) GetWeekMetrics(ctx context.Context) (GetWeekMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getWeekMetrics)
	var i GetWeekMetricsRow
	err := row.Scan(&i.SessionsWeek, &i.CostWeek)
	return i, err
}

const listSessions = `-- name: ListSessions :many
SELECT
    id, session_id, hostname, timestamp, exit_reason,
    working_directory, git_branch, duration_seconds,
    user_prompts, tool_calls, estimated_cost_usd, model
FROM sessions
ORDER BY timestamp DESC
LIMIT ? OFFSET ?
`

type ListSessionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListSessionsRow struct {
	ID               int64           `json:"id"`
	SessionID        string          `json:"session_id"`
	Hostname         string          `json:"hostname"`
	Timestamp        string          `json:"timestamp"`
	ExitReason       sql.NullString  `json:"exit_reason"`
	WorkingDirectory sql.NullString  `json:"working_directory"`
	GitBranch        sql.NullString  `json:"git_branch"`
	DurationSeconds  sql.NullInt64   `json:"duration_seconds"`
	UserPrompts      sql.NullInt64   `json:"user_prompts"`
	ToolCalls        sql.NullInt64   `json:"tool_calls"`
	EstimatedCostUsd sql.NullFloat64 `json:"estimated_cost_usd"`
	Model            sql.NullString  `json:"model"`
}

func (q *Queries) ListSessions(ctx context.Context, arg ListSessionsParams) ([]ListSessionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsRow{}
	for rows.Next() {
		var i ListSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Hostname,
			&i.Timestamp,
			&i.ExitReason,
			&i.WorkingDirectory,
			&i.GitBranch,
			&i.DurationSeconds,
			&i.UserPrompts,
			&i.ToolCalls,
			&i.EstimatedCostUsd,
			&i.Model,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
