package productivity

import (
	"encoding/json"
	"fmt"
	"claude-watcher/internal/shared/templates"
)

templ Productivity(data ProductivityData) {
	@templates.Layout("Productivity") {
		<h1>Productivity Analytics</h1>
		<div class="time-range">
			<a href="/productivity?range=7d" class={ "time-range__btn", templ.KV("time-range__btn--active", data.Range == "7d") }>7D</a>
			<a href="/productivity?range=30d" class={ "time-range__btn", templ.KV("time-range__btn--active", data.Range == "30d") }>30D</a>
			<a href="/productivity?range=90d" class={ "time-range__btn", templ.KV("time-range__btn--active", data.Range == "90d") }>90D</a>
		</div>

		<section>
			<h2>Session Efficiency</h2>
			<div class="stats-grid">
				@templates.StatsCard("Prompts/Session", fmt.Sprintf("%.1f", toFloat(data.Efficiency.AvgPromptsPerSession)), "sessions")
				@templates.StatsCard("Tools/Session", fmt.Sprintf("%.1f", toFloat(data.Efficiency.AvgToolsPerSession)), "tokens")
				@templates.StatsCard("Error Rate", fmt.Sprintf("%.1f%%", toFloat(data.Efficiency.ErrorRate)*100), "cost")
				@templates.StatsCard("Avg Duration", fmt.Sprintf("%.0f min", toFloat(data.Efficiency.AvgDuration)/60), "sessions")
			</div>
		</section>

		<section>
			<h2>Top Tools</h2>
			<div class="charts-grid">
				<div class="chart-card">
					<div class="chart-card__title">Tool Usage</div>
					<div class="chart-card__container">
						<canvas id="toolsChart"></canvas>
					</div>
				</div>
				<div class="chart-card">
					<div class="chart-card__title">Tool Breakdown</div>
					<div class="chart-card__content">
						<table class="data-table">
							<thead>
								<tr>
									<th>Tool</th>
									<th>Count</th>
								</tr>
							</thead>
							<tbody>
								for _, tool := range data.TopTools {
									<tr>
										<td>{ tool.Name }</td>
										<td>{ fmt.Sprintf("%d", tool.Count) }</td>
									</tr>
								}
								if len(data.TopTools) == 0 {
									<tr>
										<td colspan="2" class="text-center">No tool usage data</td>
									</tr>
								}
							</tbody>
						</table>
					</div>
				</div>
			</div>
		</section>

		<section>
			<h2>Time Patterns</h2>
			<div class="charts-grid">
				<div class="chart-card">
					<div class="chart-card__title">Activity by Day of Week</div>
					<div class="chart-card__container">
						<canvas id="dayOfWeekChart"></canvas>
					</div>
				</div>
				<div class="chart-card">
					<div class="chart-card__title">Activity by Hour of Day</div>
					<div class="chart-card__container">
						<canvas id="hourOfDayChart"></canvas>
					</div>
				</div>
			</div>
		</section>

		<section>
			<h2>Efficiency Trends</h2>
			<div class="charts-grid">
				<div class="chart-card chart-card--full">
					<div class="chart-card__title">Daily Efficiency Metrics</div>
					<div class="chart-card__container chart-card__container--full">
						<canvas id="efficiencyTrendChart"></canvas>
					</div>
				</div>
			</div>
		</section>

		<div id="chartData" style="display:none;">{ mustJSON(buildChartData(data)) }</div>
		@chartsScript()
	}
}

templ chartsScript() {
	<script>
		(function() {
			const data = JSON.parse(document.getElementById('chartData').textContent);

			const colors = {
				primary: '#22c55e',
				secondary: '#3b82f6',
				tertiary: '#f59e0b',
				grid: '#1a1a1a',
				text: '#666666'
			};

			const baseOptions = {
				responsive: true,
				maintainAspectRatio: false,
				animation: false,
				plugins: { legend: { labels: { color: colors.text } } },
				scales: {
					x: { grid: { color: colors.grid }, ticks: { color: colors.text } },
					y: { grid: { color: colors.grid }, ticks: { color: colors.text }, beginAtZero: true }
				}
			};

			// Top Tools Chart
			if (data.tools && data.tools.length > 0) {
				new Chart(document.getElementById('toolsChart'), {
					type: 'bar',
					data: {
						labels: data.tools.map(t => t.name),
						datasets: [{
							label: 'Usage Count',
							data: data.tools.map(t => t.count),
							backgroundColor: colors.primary + '80',
							borderColor: colors.primary,
							borderWidth: 1
						}]
					},
					options: {
						...baseOptions,
						indexAxis: 'y',
						plugins: { legend: { display: false } }
					}
				});
			}

			// Day of Week Chart
			const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
			const dayData = new Array(7).fill(0);
			(data.dayOfWeek || []).forEach(d => { dayData[d.day] = d.sessions; });

			new Chart(document.getElementById('dayOfWeekChart'), {
				type: 'bar',
				data: {
					labels: dayNames,
					datasets: [{
						label: 'Sessions',
						data: dayData,
						backgroundColor: colors.secondary + '80',
						borderColor: colors.secondary,
						borderWidth: 1
					}]
				},
				options: baseOptions
			});

			// Hour of Day Chart
			const hourLabels = Array.from({length: 24}, (_, i) => `${i}:00`);
			const hourData = new Array(24).fill(0);
			(data.hourOfDay || []).forEach(d => { hourData[d.hour] = d.sessions; });

			new Chart(document.getElementById('hourOfDayChart'), {
				type: 'bar',
				data: {
					labels: hourLabels,
					datasets: [{
						label: 'Sessions',
						data: hourData,
						backgroundColor: colors.tertiary + '80',
						borderColor: colors.tertiary,
						borderWidth: 1
					}]
				},
				options: baseOptions
			});

			// Efficiency Trend Chart
			if (data.trends && data.trends.length > 0) {
				new Chart(document.getElementById('efficiencyTrendChart'), {
					type: 'line',
					data: {
						labels: data.trends.map(t => t.period),
						datasets: [
							{
								label: 'Avg Prompts',
								data: data.trends.map(t => t.avgPrompts),
								borderColor: colors.primary,
								backgroundColor: 'transparent',
								tension: 0.3
							},
							{
								label: 'Avg Tools',
								data: data.trends.map(t => t.avgTools),
								borderColor: colors.secondary,
								backgroundColor: 'transparent',
								tension: 0.3
							},
							{
								label: 'Sessions',
								data: data.trends.map(t => t.sessions),
								borderColor: colors.tertiary,
								backgroundColor: 'transparent',
								tension: 0.3,
								yAxisID: 'y1'
							}
						]
					},
					options: {
						...baseOptions,
						scales: {
							x: baseOptions.scales.x,
							y: { ...baseOptions.scales.y, position: 'left' },
							y1: { ...baseOptions.scales.y, position: 'right', grid: { drawOnChartArea: false } }
						}
					}
				});
			}
		})();
	</script>
}

type chartData struct {
	Tools     []toolData  `json:"tools"`
	DayOfWeek []dayData   `json:"dayOfWeek"`
	HourOfDay []hourData  `json:"hourOfDay"`
	Trends    []trendData `json:"trends"`
}

type toolData struct {
	Name  string `json:"name"`
	Count int    `json:"count"`
}

type dayData struct {
	Day      int   `json:"day"`
	Sessions int64 `json:"sessions"`
}

type hourData struct {
	Hour     int   `json:"hour"`
	Sessions int64 `json:"sessions"`
}

type trendData struct {
	Period     string  `json:"period"`
	AvgPrompts float64 `json:"avgPrompts"`
	AvgTools   float64 `json:"avgTools"`
	Sessions   int64   `json:"sessions"`
}

func buildChartData(data ProductivityData) chartData {
	cd := chartData{
		Tools:     make([]toolData, len(data.TopTools)),
		DayOfWeek: make([]dayData, len(data.DayOfWeek)),
		HourOfDay: make([]hourData, len(data.HourOfDay)),
		Trends:    make([]trendData, len(data.DailyTrends)),
	}

	for i, t := range data.TopTools {
		cd.Tools[i] = toolData{Name: t.Name, Count: t.Count}
	}

	for i, d := range data.DayOfWeek {
		cd.DayOfWeek[i] = dayData{Day: toInt(d.DayOfWeek), Sessions: d.Sessions}
	}

	for i, h := range data.HourOfDay {
		cd.HourOfDay[i] = hourData{Hour: toInt(h.Hour), Sessions: h.Sessions}
	}

	for i, t := range data.DailyTrends {
		cd.Trends[i] = trendData{
			Period:     toString(t.Period),
			AvgPrompts: toFloat(t.AvgPrompts),
			AvgTools:   toFloat(t.AvgTools),
			Sessions:   t.Sessions,
		}
	}

	return cd
}

func mustJSON(v interface{}) string {
	b, _ := json.Marshal(v)
	return string(b)
}

func toFloat(v interface{}) float64 {
	switch val := v.(type) {
	case float64:
		return val
	case int64:
		return float64(val)
	case int:
		return float64(val)
	default:
		return 0
	}
}

func toInt(v interface{}) int {
	switch val := v.(type) {
	case int64:
		return int(val)
	case int:
		return val
	case float64:
		return int(val)
	default:
		return 0
	}
}

func toString(v interface{}) string {
	switch val := v.(type) {
	case string:
		return val
	default:
		return fmt.Sprintf("%v", v)
	}
}
