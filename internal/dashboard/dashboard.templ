package dashboard

import (
	"fmt"
	"path/filepath"
	"claude-watcher/internal/shared/templates"
)

templ Dashboard(data DashboardData) {
	@templates.Layout("Dashboard") {
		<h1>Dashboard</h1>
		<div class="stats-grid">
			@templates.StatsCard("Total Sessions", fmt.Sprintf("%d", data.Metrics.TotalSessions), "sessions")
			@templates.StatsCard("Total Cost", fmt.Sprintf("$%.2f", toFloat(data.Metrics.TotalCostUsd)), "cost")
			@templates.StatsCard("Total Tool Calls", fmt.Sprintf("%v", data.Metrics.TotalToolCalls), "tokens")
			@templates.StatsCard("Avg Duration", fmt.Sprintf("%.0f min", toFloat(data.Metrics.AvgDurationSeconds)/60), "sessions")
		</div>
		<section>
			<h2>Quick Insights</h2>
			<div class="stats-grid">
				@templates.StatsCard("Cache Hit Rate", fmt.Sprintf("%.1f%%", data.CacheHitRate), "tokens")
				@templates.StatsCard("Top Tool", data.TopTool, "sessions")
				@templates.StatsCard("Top Project", shortPath(data.TopProject.Directory), "sessions")
				@templates.StatsCard("Prompts/Session", fmt.Sprintf("%.1f", toFloat(data.EfficiencyMetrics.AvgPromptsPerSession)), "cost")
			</div>
		</section>
		<section>
			<h2>Today</h2>
			<div class="stats-grid">
				@templates.StatsCard("Sessions", fmt.Sprintf("%d", data.Today.SessionsToday), "sessions")
				@templates.StatsCard("Cost", fmt.Sprintf("$%.2f", toFloat(data.Today.CostToday)), "cost")
			</div>
		</section>
		<section>
			<h2>This Week</h2>
			<div class="stats-grid">
				@templates.StatsCard("Sessions", fmt.Sprintf("%d", data.Week.SessionsWeek), "sessions")
				@templates.StatsCard("Cost", fmt.Sprintf("$%.2f", toFloat(data.Week.CostWeek)), "cost")
			</div>
		</section>
		<section id="charts-section">
			<h2>Historical Trends</h2>
			<div class="time-range">
				<button class="time-range__btn time-range__btn--active" data-range="7d">7D</button>
				<button class="time-range__btn" data-range="30d">30D</button>
				<button class="time-range__btn" data-range="90d">90D</button>
			</div>
			<div class="charts-grid">
				<div class="chart-card chart-card--full">
					<div class="chart-card__title">Sessions & Cost Over Time</div>
					<div class="chart-card__container chart-card__container--full">
						<canvas id="timeSeriesChart"></canvas>
					</div>
				</div>
				<div class="chart-card">
					<div class="chart-card__title">Cost by Model</div>
					<div class="chart-card__container">
						<canvas id="modelChart"></canvas>
					</div>
				</div>
				<div class="chart-card">
					<div class="chart-card__title">Activity by Hour of Day</div>
					<div class="chart-card__container">
						<canvas id="hourChart"></canvas>
					</div>
				</div>
				<div class="chart-card chart-card--full">
					<div class="chart-card__title">Token Usage Over Time</div>
					<div class="chart-card__container chart-card__container--full">
						<canvas id="tokenChart"></canvas>
					</div>
				</div>
			</div>
		</section>
		@chartsScript()
	}
}

templ chartsScript() {
	<script>
		(function() {
			const charts = {};
			const cache = {};
			const ranges = ['7d', '30d', '90d'];
			let currentRange = '7d';

			const colors = {
				primary: '#22c55e',
				secondary: '#3b82f6',
				input: '#3b82f6',
				output: '#22c55e',
				thinking: '#f59e0b',
				grid: '#1a1a1a',
				text: '#666666'
			};

			const baseOptions = {
				responsive: true,
				maintainAspectRatio: false,
				animation: false,
				plugins: { legend: { labels: { color: colors.text } } },
				scales: {
					x: { grid: { color: colors.grid }, ticks: { color: colors.text } },
					y: { grid: { color: colors.grid }, ticks: { color: colors.text } }
				}
			};

			function formatLabel(period) {
				if (!period) return '';
				if (period.includes('T')) {
					return new Date(period).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
				}
				return new Date(period).toLocaleDateString([], { month: 'short', day: 'numeric' });
			}

			function formatModel(m) {
				if (!m) return 'Unknown';
				return m.replace('claude-', '').replace(/-\d+$/, '');
			}

			function createChart(id, config) {
				const el = document.getElementById(id);
				if (!el) return;
				if (charts[id]) charts[id].destroy();
				charts[id] = new Chart(el, config);
			}

			function renderCharts(data) {
				if (!data) return;

				const ts = data.timeSeries || [];
				createChart('timeSeriesChart', {
					type: 'line',
					data: {
						labels: ts.map(d => formatLabel(d.period)),
						datasets: [
							{ label: 'Sessions', data: ts.map(d => d.sessions), borderColor: colors.primary, backgroundColor: colors.primary + '15', fill: true, tension: 0.3, yAxisID: 'y' },
							{ label: 'Cost ($)', data: ts.map(d => d.cost), borderColor: colors.secondary, backgroundColor: 'transparent', tension: 0.3, yAxisID: 'y1' }
						]
					},
					options: { ...baseOptions, scales: { x: baseOptions.scales.x, y: { ...baseOptions.scales.y, position: 'left', beginAtZero: true }, y1: { ...baseOptions.scales.y, position: 'right', beginAtZero: true, grid: { drawOnChartArea: false } } } }
				});

				const models = data.models || [];
				if (models.length > 0) {
					createChart('modelChart', {
						type: 'doughnut',
						data: {
							labels: models.map(d => formatModel(d.model)),
							datasets: [{ data: models.map(d => d.cost), backgroundColor: ['#22c55e', '#3b82f6', '#f59e0b', '#8b5cf6', '#ec4899'], borderColor: '#0a0a0a', borderWidth: 2 }]
						},
						options: { responsive: true, maintainAspectRatio: false, animation: false, plugins: { legend: { position: 'bottom', labels: { color: colors.text } } } }
					});
				}

				const hourLabels = Array.from({length: 24}, (_, i) => `${i}:00`);
				const hourData = hourLabels.map((_, i) => {
					const found = (data.hourOfDay || []).find(d => d.hour === i);
					return found ? found.sessions : 0;
				});
				createChart('hourChart', {
					type: 'bar',
					data: { labels: hourLabels, datasets: [{ label: 'Sessions', data: hourData, backgroundColor: colors.primary + '60', borderColor: colors.primary, borderWidth: 1 }] },
					options: baseOptions
				});

				createChart('tokenChart', {
					type: 'bar',
					data: {
						labels: ts.map(d => formatLabel(d.period)),
						datasets: [
							{ label: 'Input', data: ts.map(d => d.tokens?.input || 0), backgroundColor: colors.input },
							{ label: 'Output', data: ts.map(d => d.tokens?.output || 0), backgroundColor: colors.output },
							{ label: 'Thinking', data: ts.map(d => d.tokens?.thinking || 0), backgroundColor: colors.thinking }
						]
					},
					options: { ...baseOptions, scales: { x: { ...baseOptions.scales.x, stacked: true }, y: { ...baseOptions.scales.y, stacked: true, beginAtZero: true } } }
				});
			}

			function setActiveButton(range) {
				document.querySelectorAll('.time-range__btn').forEach(btn => {
					btn.classList.toggle('time-range__btn--active', btn.dataset.range === range);
				});
			}

			async function init() {
				// Preload all ranges
				await Promise.all(ranges.map(r =>
					fetch(`/api/charts?range=${r}`)
						.then(res => res.json())
						.then(data => { cache[r] = data; })
						.catch(err => console.error(`Failed to fetch ${r}:`, err))
				));

				// Render initial
				renderCharts(cache[currentRange]);

				// Button click handlers
				document.querySelectorAll('.time-range__btn').forEach(btn => {
					btn.addEventListener('click', () => {
						currentRange = btn.dataset.range;
						setActiveButton(currentRange);
						renderCharts(cache[currentRange]);
					});
				});
			}

			init();
		})();
	</script>
}

func toFloat(v interface{}) float64 {
	switch val := v.(type) {
	case float64:
		return val
	case int64:
		return float64(val)
	case int:
		return float64(val)
	default:
		return 0
	}
}

func shortPath(path string) string {
	if path == "" || path == "Unknown" {
		return "-"
	}
	return filepath.Base(path)
}
