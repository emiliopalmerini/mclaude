// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countSessions = `-- name: CountSessions :one
SELECT COUNT(*) FROM sessions
`

func (q *Queries) CountSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSessionsInRange = `-- name: CountSessionsInRange :one
SELECT COUNT(*) FROM sessions
WHERE timestamp >= ? AND timestamp <= ?
`

type CountSessionsInRangeParams struct {
	Timestamp   string `json:"timestamp"`
	Timestamp_2 string `json:"timestamp_2"`
}

func (q *Queries) CountSessionsInRange(ctx context.Context, arg CountSessionsInRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSessionsInRange, arg.Timestamp, arg.Timestamp_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAverageRatingsInRange = `-- name: GetAverageRatingsInRange :one
SELECT
    AVG(rating) as avg_rating,
    AVG(prompt_specificity) as avg_prompt_specificity,
    AVG(task_completion) as avg_task_completion,
    AVG(code_confidence) as avg_code_confidence
FROM sessions
WHERE timestamp >= ? AND timestamp <= ?
  AND (rating IS NOT NULL OR prompt_specificity IS NOT NULL
       OR task_completion IS NOT NULL OR code_confidence IS NOT NULL)
`

type GetAverageRatingsInRangeParams struct {
	Timestamp   string `json:"timestamp"`
	Timestamp_2 string `json:"timestamp_2"`
}

type GetAverageRatingsInRangeRow struct {
	AvgRating            sql.NullFloat64 `json:"avg_rating"`
	AvgPromptSpecificity sql.NullFloat64 `json:"avg_prompt_specificity"`
	AvgTaskCompletion    sql.NullFloat64 `json:"avg_task_completion"`
	AvgCodeConfidence    sql.NullFloat64 `json:"avg_code_confidence"`
}

func (q *Queries) GetAverageRatingsInRange(ctx context.Context, arg GetAverageRatingsInRangeParams) (GetAverageRatingsInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getAverageRatingsInRange, arg.Timestamp, arg.Timestamp_2)
	var i GetAverageRatingsInRangeRow
	err := row.Scan(
		&i.AvgRating,
		&i.AvgPromptSpecificity,
		&i.AvgTaskCompletion,
		&i.AvgCodeConfidence,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, session_id, instance_id, hostname, timestamp, working_directory, git_branch, model, claude_version, exit_reason, permission_mode, user_prompts, assistant_responses, tool_calls, tools_breakdown, errors_count, input_tokens, output_tokens, thinking_tokens, cache_read_tokens, cache_write_tokens, estimated_cost_usd, files_accessed, files_modified, prompt_specificity, task_completion, code_confidence, rating, task_type, notes, created_at FROM sessions WHERE session_id = ?
`

func (q *Queries) GetSession(ctx context.Context, sessionID string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, sessionID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.InstanceID,
		&i.Hostname,
		&i.Timestamp,
		&i.WorkingDirectory,
		&i.GitBranch,
		&i.Model,
		&i.ClaudeVersion,
		&i.ExitReason,
		&i.PermissionMode,
		&i.UserPrompts,
		&i.AssistantResponses,
		&i.ToolCalls,
		&i.ToolsBreakdown,
		&i.ErrorsCount,
		&i.InputTokens,
		&i.OutputTokens,
		&i.ThinkingTokens,
		&i.CacheReadTokens,
		&i.CacheWriteTokens,
		&i.EstimatedCostUsd,
		&i.FilesAccessed,
		&i.FilesModified,
		&i.PromptSpecificity,
		&i.TaskCompletion,
		&i.CodeConfidence,
		&i.Rating,
		&i.TaskType,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getTotalCostInRange = `-- name: GetTotalCostInRange :one
SELECT COALESCE(SUM(estimated_cost_usd), 0) as total_cost
FROM sessions
WHERE timestamp >= ? AND timestamp <= ?
`

type GetTotalCostInRangeParams struct {
	Timestamp   string `json:"timestamp"`
	Timestamp_2 string `json:"timestamp_2"`
}

func (q *Queries) GetTotalCostInRange(ctx context.Context, arg GetTotalCostInRangeParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalCostInRange, arg.Timestamp, arg.Timestamp_2)
	var total_cost interface{}
	err := row.Scan(&total_cost)
	return total_cost, err
}

const getTotalTokensInRange = `-- name: GetTotalTokensInRange :one
SELECT
    COALESCE(SUM(input_tokens), 0) as input_tokens,
    COALESCE(SUM(output_tokens), 0) as output_tokens,
    COALESCE(SUM(thinking_tokens), 0) as thinking_tokens,
    COALESCE(SUM(cache_read_tokens), 0) as cache_read_tokens,
    COALESCE(SUM(cache_write_tokens), 0) as cache_write_tokens
FROM sessions
WHERE timestamp >= ? AND timestamp <= ?
`

type GetTotalTokensInRangeParams struct {
	Timestamp   string `json:"timestamp"`
	Timestamp_2 string `json:"timestamp_2"`
}

type GetTotalTokensInRangeRow struct {
	InputTokens      interface{} `json:"input_tokens"`
	OutputTokens     interface{} `json:"output_tokens"`
	ThinkingTokens   interface{} `json:"thinking_tokens"`
	CacheReadTokens  interface{} `json:"cache_read_tokens"`
	CacheWriteTokens interface{} `json:"cache_write_tokens"`
}

func (q *Queries) GetTotalTokensInRange(ctx context.Context, arg GetTotalTokensInRangeParams) (GetTotalTokensInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getTotalTokensInRange, arg.Timestamp, arg.Timestamp_2)
	var i GetTotalTokensInRangeRow
	err := row.Scan(
		&i.InputTokens,
		&i.OutputTokens,
		&i.ThinkingTokens,
		&i.CacheReadTokens,
		&i.CacheWriteTokens,
	)
	return i, err
}

const insertSession = `-- name: InsertSession :exec
INSERT INTO sessions (
    session_id,
    instance_id,
    hostname,
    timestamp,
    working_directory,
    git_branch,
    model,
    claude_version,
    exit_reason,
    permission_mode,
    user_prompts,
    assistant_responses,
    tool_calls,
    tools_breakdown,
    errors_count,
    input_tokens,
    output_tokens,
    thinking_tokens,
    cache_read_tokens,
    cache_write_tokens,
    estimated_cost_usd,
    files_accessed,
    files_modified,
    prompt_specificity,
    task_completion,
    code_confidence,
    rating,
    task_type,
    notes
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type InsertSessionParams struct {
	SessionID          string          `json:"session_id"`
	InstanceID         sql.NullString  `json:"instance_id"`
	Hostname           sql.NullString  `json:"hostname"`
	Timestamp          string          `json:"timestamp"`
	WorkingDirectory   sql.NullString  `json:"working_directory"`
	GitBranch          sql.NullString  `json:"git_branch"`
	Model              sql.NullString  `json:"model"`
	ClaudeVersion      sql.NullString  `json:"claude_version"`
	ExitReason         sql.NullString  `json:"exit_reason"`
	PermissionMode     sql.NullString  `json:"permission_mode"`
	UserPrompts        sql.NullInt64   `json:"user_prompts"`
	AssistantResponses sql.NullInt64   `json:"assistant_responses"`
	ToolCalls          sql.NullInt64   `json:"tool_calls"`
	ToolsBreakdown     sql.NullString  `json:"tools_breakdown"`
	ErrorsCount        sql.NullInt64   `json:"errors_count"`
	InputTokens        sql.NullInt64   `json:"input_tokens"`
	OutputTokens       sql.NullInt64   `json:"output_tokens"`
	ThinkingTokens     sql.NullInt64   `json:"thinking_tokens"`
	CacheReadTokens    sql.NullInt64   `json:"cache_read_tokens"`
	CacheWriteTokens   sql.NullInt64   `json:"cache_write_tokens"`
	EstimatedCostUsd   sql.NullFloat64 `json:"estimated_cost_usd"`
	FilesAccessed      sql.NullString  `json:"files_accessed"`
	FilesModified      sql.NullString  `json:"files_modified"`
	PromptSpecificity  sql.NullInt64   `json:"prompt_specificity"`
	TaskCompletion     sql.NullInt64   `json:"task_completion"`
	CodeConfidence     sql.NullInt64   `json:"code_confidence"`
	Rating             sql.NullInt64   `json:"rating"`
	TaskType           sql.NullString  `json:"task_type"`
	Notes              sql.NullString  `json:"notes"`
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.ExecContext(ctx, insertSession,
		arg.SessionID,
		arg.InstanceID,
		arg.Hostname,
		arg.Timestamp,
		arg.WorkingDirectory,
		arg.GitBranch,
		arg.Model,
		arg.ClaudeVersion,
		arg.ExitReason,
		arg.PermissionMode,
		arg.UserPrompts,
		arg.AssistantResponses,
		arg.ToolCalls,
		arg.ToolsBreakdown,
		arg.ErrorsCount,
		arg.InputTokens,
		arg.OutputTokens,
		arg.ThinkingTokens,
		arg.CacheReadTokens,
		arg.CacheWriteTokens,
		arg.EstimatedCostUsd,
		arg.FilesAccessed,
		arg.FilesModified,
		arg.PromptSpecificity,
		arg.TaskCompletion,
		arg.CodeConfidence,
		arg.Rating,
		arg.TaskType,
		arg.Notes,
	)
	return err
}

const listSessions = `-- name: ListSessions :many
SELECT id, session_id, instance_id, hostname, timestamp, working_directory, git_branch, model, claude_version, exit_reason, permission_mode, user_prompts, assistant_responses, tool_calls, tools_breakdown, errors_count, input_tokens, output_tokens, thinking_tokens, cache_read_tokens, cache_write_tokens, estimated_cost_usd, files_accessed, files_modified, prompt_specificity, task_completion, code_confidence, rating, task_type, notes, created_at FROM sessions
ORDER BY timestamp DESC
LIMIT ? OFFSET ?
`

type ListSessionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSessions(ctx context.Context, arg ListSessionsParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.InstanceID,
			&i.Hostname,
			&i.Timestamp,
			&i.WorkingDirectory,
			&i.GitBranch,
			&i.Model,
			&i.ClaudeVersion,
			&i.ExitReason,
			&i.PermissionMode,
			&i.UserPrompts,
			&i.AssistantResponses,
			&i.ToolCalls,
			&i.ToolsBreakdown,
			&i.ErrorsCount,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ThinkingTokens,
			&i.CacheReadTokens,
			&i.CacheWriteTokens,
			&i.EstimatedCostUsd,
			&i.FilesAccessed,
			&i.FilesModified,
			&i.PromptSpecificity,
			&i.TaskCompletion,
			&i.CodeConfidence,
			&i.Rating,
			&i.TaskType,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsInRange = `-- name: ListSessionsInRange :many
SELECT id, session_id, instance_id, hostname, timestamp, working_directory, git_branch, model, claude_version, exit_reason, permission_mode, user_prompts, assistant_responses, tool_calls, tools_breakdown, errors_count, input_tokens, output_tokens, thinking_tokens, cache_read_tokens, cache_write_tokens, estimated_cost_usd, files_accessed, files_modified, prompt_specificity, task_completion, code_confidence, rating, task_type, notes, created_at FROM sessions
WHERE timestamp >= ? AND timestamp <= ?
ORDER BY timestamp DESC
`

type ListSessionsInRangeParams struct {
	Timestamp   string `json:"timestamp"`
	Timestamp_2 string `json:"timestamp_2"`
}

func (q *Queries) ListSessionsInRange(ctx context.Context, arg ListSessionsInRangeParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsInRange, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.InstanceID,
			&i.Hostname,
			&i.Timestamp,
			&i.WorkingDirectory,
			&i.GitBranch,
			&i.Model,
			&i.ClaudeVersion,
			&i.ExitReason,
			&i.PermissionMode,
			&i.UserPrompts,
			&i.AssistantResponses,
			&i.ToolCalls,
			&i.ToolsBreakdown,
			&i.ErrorsCount,
			&i.InputTokens,
			&i.OutputTokens,
			&i.ThinkingTokens,
			&i.CacheReadTokens,
			&i.CacheWriteTokens,
			&i.EstimatedCostUsd,
			&i.FilesAccessed,
			&i.FilesModified,
			&i.PromptSpecificity,
			&i.TaskCompletion,
			&i.CodeConfidence,
			&i.Rating,
			&i.TaskType,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
