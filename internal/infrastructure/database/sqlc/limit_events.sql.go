// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: limit_events.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countLimitEvents = `-- name: CountLimitEvents :one
SELECT COUNT(*) FROM limit_events
`

func (q *Queries) CountLimitEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLimitEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestLimitHit = `-- name: GetLatestLimitHit :one
SELECT id, session_id, event_type, limit_type, timestamp, message, tokens_used, cost_used, created_at FROM limit_events
WHERE event_type = 'hit'
ORDER BY timestamp DESC
LIMIT 1
`

func (q *Queries) GetLatestLimitHit(ctx context.Context) (LimitEvent, error) {
	row := q.db.QueryRowContext(ctx, getLatestLimitHit)
	var i LimitEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.EventType,
		&i.LimitType,
		&i.Timestamp,
		&i.Message,
		&i.TokensUsed,
		&i.CostUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestLimitReset = `-- name: GetLatestLimitReset :one
SELECT id, session_id, event_type, limit_type, timestamp, message, tokens_used, cost_used, created_at FROM limit_events
WHERE event_type = 'reset'
ORDER BY timestamp DESC
LIMIT 1
`

func (q *Queries) GetLatestLimitReset(ctx context.Context) (LimitEvent, error) {
	row := q.db.QueryRowContext(ctx, getLatestLimitReset)
	var i LimitEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.EventType,
		&i.LimitType,
		&i.Timestamp,
		&i.Message,
		&i.TokensUsed,
		&i.CostUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getLimitEvent = `-- name: GetLimitEvent :one
SELECT id, session_id, event_type, limit_type, timestamp, message, tokens_used, cost_used, created_at FROM limit_events WHERE id = ?
`

func (q *Queries) GetLimitEvent(ctx context.Context, id int64) (LimitEvent, error) {
	row := q.db.QueryRowContext(ctx, getLimitEvent, id)
	var i LimitEvent
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.EventType,
		&i.LimitType,
		&i.Timestamp,
		&i.Message,
		&i.TokensUsed,
		&i.CostUsed,
		&i.CreatedAt,
	)
	return i, err
}

const insertLimitEvent = `-- name: InsertLimitEvent :exec
INSERT INTO limit_events (
    session_id,
    event_type,
    limit_type,
    timestamp,
    message,
    tokens_used,
    cost_used
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertLimitEventParams struct {
	SessionID  sql.NullString  `json:"session_id"`
	EventType  string          `json:"event_type"`
	LimitType  string          `json:"limit_type"`
	Timestamp  string          `json:"timestamp"`
	Message    sql.NullString  `json:"message"`
	TokensUsed sql.NullInt64   `json:"tokens_used"`
	CostUsed   sql.NullFloat64 `json:"cost_used"`
}

func (q *Queries) InsertLimitEvent(ctx context.Context, arg InsertLimitEventParams) error {
	_, err := q.db.ExecContext(ctx, insertLimitEvent,
		arg.SessionID,
		arg.EventType,
		arg.LimitType,
		arg.Timestamp,
		arg.Message,
		arg.TokensUsed,
		arg.CostUsed,
	)
	return err
}

const listLimitEvents = `-- name: ListLimitEvents :many
SELECT id, session_id, event_type, limit_type, timestamp, message, tokens_used, cost_used, created_at FROM limit_events
ORDER BY timestamp DESC
LIMIT ? OFFSET ?
`

type ListLimitEventsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListLimitEvents(ctx context.Context, arg ListLimitEventsParams) ([]LimitEvent, error) {
	rows, err := q.db.QueryContext(ctx, listLimitEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LimitEvent{}
	for rows.Next() {
		var i LimitEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.EventType,
			&i.LimitType,
			&i.Timestamp,
			&i.Message,
			&i.TokensUsed,
			&i.CostUsed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLimitEventsInRange = `-- name: ListLimitEventsInRange :many
SELECT id, session_id, event_type, limit_type, timestamp, message, tokens_used, cost_used, created_at FROM limit_events
WHERE timestamp >= ? AND timestamp <= ?
ORDER BY timestamp DESC
`

type ListLimitEventsInRangeParams struct {
	Timestamp   string `json:"timestamp"`
	Timestamp_2 string `json:"timestamp_2"`
}

func (q *Queries) ListLimitEventsInRange(ctx context.Context, arg ListLimitEventsInRangeParams) ([]LimitEvent, error) {
	rows, err := q.db.QueryContext(ctx, listLimitEventsInRange, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LimitEvent{}
	for rows.Next() {
		var i LimitEvent
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.EventType,
			&i.LimitType,
			&i.Timestamp,
			&i.Message,
			&i.TokensUsed,
			&i.CostUsed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
