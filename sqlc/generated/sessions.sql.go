// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createSession = `-- name: CreateSession :exec
INSERT INTO sessions (id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSessionParams struct {
	ID                   string         `json:"id"`
	ProjectID            string         `json:"project_id"`
	ExperimentID         sql.NullString `json:"experiment_id"`
	TranscriptPath       string         `json:"transcript_path"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
	Cwd                  string         `json:"cwd"`
	PermissionMode       string         `json:"permission_mode"`
	ExitReason           string         `json:"exit_reason"`
	StartedAt            sql.NullString `json:"started_at"`
	EndedAt              sql.NullString `json:"ended_at"`
	DurationSeconds      sql.NullInt64  `json:"duration_seconds"`
	CreatedAt            string         `json:"created_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession,
		arg.ID,
		arg.ProjectID,
		arg.ExperimentID,
		arg.TranscriptPath,
		arg.TranscriptStoredPath,
		arg.Cwd,
		arg.PermissionMode,
		arg.ExitReason,
		arg.StartedAt,
		arg.EndedAt,
		arg.DurationSeconds,
		arg.CreatedAt,
	)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const deleteSessionsBefore = `-- name: DeleteSessionsBefore :execrows
DELETE FROM sessions WHERE created_at < ?
`

func (q *Queries) DeleteSessionsBefore(ctx context.Context, createdAt string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSessionsBefore, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteSessionsByExperiment = `-- name: DeleteSessionsByExperiment :execrows
DELETE FROM sessions WHERE experiment_id = ?
`

func (q *Queries) DeleteSessionsByExperiment(ctx context.Context, experimentID sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSessionsByExperiment, experimentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteSessionsByProject = `-- name: DeleteSessionsByProject :execrows
DELETE FROM sessions WHERE project_id = ?
`

func (q *Queries) DeleteSessionsByProject(ctx context.Context, projectID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSessionsByProject, projectID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at FROM sessions WHERE id = ?
`

func (q *Queries) GetSessionByID(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ExperimentID,
		&i.TranscriptPath,
		&i.TranscriptStoredPath,
		&i.Cwd,
		&i.PermissionMode,
		&i.ExitReason,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionTranscriptPaths = `-- name: GetSessionTranscriptPaths :many
SELECT id, transcript_stored_path FROM sessions WHERE transcript_stored_path IS NOT NULL
`

type GetSessionTranscriptPathsRow struct {
	ID                   string         `json:"id"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
}

func (q *Queries) GetSessionTranscriptPaths(ctx context.Context) ([]GetSessionTranscriptPathsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTranscriptPaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionTranscriptPathsRow{}
	for rows.Next() {
		var i GetSessionTranscriptPathsRow
		if err := rows.Scan(&i.ID, &i.TranscriptStoredPath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionTranscriptPathsBefore = `-- name: GetSessionTranscriptPathsBefore :many
SELECT id, transcript_stored_path FROM sessions WHERE created_at < ? AND transcript_stored_path IS NOT NULL
`

type GetSessionTranscriptPathsBeforeRow struct {
	ID                   string         `json:"id"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
}

func (q *Queries) GetSessionTranscriptPathsBefore(ctx context.Context, createdAt string) ([]GetSessionTranscriptPathsBeforeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTranscriptPathsBefore, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionTranscriptPathsBeforeRow{}
	for rows.Next() {
		var i GetSessionTranscriptPathsBeforeRow
		if err := rows.Scan(&i.ID, &i.TranscriptStoredPath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionTranscriptPathsByExperiment = `-- name: GetSessionTranscriptPathsByExperiment :many
SELECT id, transcript_stored_path FROM sessions WHERE experiment_id = ? AND transcript_stored_path IS NOT NULL
`

type GetSessionTranscriptPathsByExperimentRow struct {
	ID                   string         `json:"id"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
}

func (q *Queries) GetSessionTranscriptPathsByExperiment(ctx context.Context, experimentID sql.NullString) ([]GetSessionTranscriptPathsByExperimentRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTranscriptPathsByExperiment, experimentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionTranscriptPathsByExperimentRow{}
	for rows.Next() {
		var i GetSessionTranscriptPathsByExperimentRow
		if err := rows.Scan(&i.ID, &i.TranscriptStoredPath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionTranscriptPathsByProject = `-- name: GetSessionTranscriptPathsByProject :many
SELECT id, transcript_stored_path FROM sessions WHERE project_id = ? AND transcript_stored_path IS NOT NULL
`

type GetSessionTranscriptPathsByProjectRow struct {
	ID                   string         `json:"id"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
}

func (q *Queries) GetSessionTranscriptPathsByProject(ctx context.Context, projectID string) ([]GetSessionTranscriptPathsByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTranscriptPathsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionTranscriptPathsByProjectRow{}
	for rows.Next() {
		var i GetSessionTranscriptPathsByProjectRow
		if err := rows.Scan(&i.ID, &i.TranscriptStoredPath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at FROM sessions
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListSessions(ctx context.Context, limit int64) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.TranscriptPath,
			&i.TranscriptStoredPath,
			&i.Cwd,
			&i.PermissionMode,
			&i.ExitReason,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByExperiment = `-- name: ListSessionsByExperiment :many
SELECT id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at FROM sessions
WHERE experiment_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListSessionsByExperimentParams struct {
	ExperimentID sql.NullString `json:"experiment_id"`
	Limit        int64          `json:"limit"`
}

func (q *Queries) ListSessionsByExperiment(ctx context.Context, arg ListSessionsByExperimentParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsByExperiment, arg.ExperimentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.TranscriptPath,
			&i.TranscriptStoredPath,
			&i.Cwd,
			&i.PermissionMode,
			&i.ExitReason,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByProject = `-- name: ListSessionsByProject :many
SELECT id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at FROM sessions
WHERE project_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListSessionsByProjectParams struct {
	ProjectID string `json:"project_id"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) ListSessionsByProject(ctx context.Context, arg ListSessionsByProjectParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsByProject, arg.ProjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.TranscriptPath,
			&i.TranscriptStoredPath,
			&i.Cwd,
			&i.PermissionMode,
			&i.ExitReason,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
