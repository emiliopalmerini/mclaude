// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createSession = `-- name: CreateSession :exec
INSERT OR REPLACE INTO sessions (id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSessionParams struct {
	ID                   string         `json:"id"`
	ProjectID            string         `json:"project_id"`
	ExperimentID         sql.NullString `json:"experiment_id"`
	TranscriptPath       string         `json:"transcript_path"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
	Cwd                  string         `json:"cwd"`
	PermissionMode       string         `json:"permission_mode"`
	ExitReason           string         `json:"exit_reason"`
	StartedAt            sql.NullString `json:"started_at"`
	EndedAt              sql.NullString `json:"ended_at"`
	DurationSeconds      sql.NullInt64  `json:"duration_seconds"`
	CreatedAt            string         `json:"created_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession,
		arg.ID,
		arg.ProjectID,
		arg.ExperimentID,
		arg.TranscriptPath,
		arg.TranscriptStoredPath,
		arg.Cwd,
		arg.PermissionMode,
		arg.ExitReason,
		arg.StartedAt,
		arg.EndedAt,
		arg.DurationSeconds,
		arg.CreatedAt,
	)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const deleteSessionsBefore = `-- name: DeleteSessionsBefore :execrows
DELETE FROM sessions WHERE created_at < ?
`

func (q *Queries) DeleteSessionsBefore(ctx context.Context, createdAt string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSessionsBefore, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteSessionsByExperiment = `-- name: DeleteSessionsByExperiment :execrows
DELETE FROM sessions WHERE experiment_id = ?
`

func (q *Queries) DeleteSessionsByExperiment(ctx context.Context, experimentID sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSessionsByExperiment, experimentID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteSessionsByProject = `-- name: DeleteSessionsByProject :execrows
DELETE FROM sessions WHERE project_id = ?
`

func (q *Queries) DeleteSessionsByProject(ctx context.Context, projectID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSessionsByProject, projectID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at FROM sessions WHERE id = ?
`

func (q *Queries) GetSessionByID(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ExperimentID,
		&i.TranscriptPath,
		&i.TranscriptStoredPath,
		&i.Cwd,
		&i.PermissionMode,
		&i.ExitReason,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionTranscriptPaths = `-- name: GetSessionTranscriptPaths :many
SELECT id, transcript_stored_path FROM sessions WHERE transcript_stored_path IS NOT NULL
`

type GetSessionTranscriptPathsRow struct {
	ID                   string         `json:"id"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
}

func (q *Queries) GetSessionTranscriptPaths(ctx context.Context) ([]GetSessionTranscriptPathsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTranscriptPaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionTranscriptPathsRow{}
	for rows.Next() {
		var i GetSessionTranscriptPathsRow
		if err := rows.Scan(&i.ID, &i.TranscriptStoredPath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionTranscriptPathsBefore = `-- name: GetSessionTranscriptPathsBefore :many
SELECT id, transcript_stored_path FROM sessions WHERE created_at < ? AND transcript_stored_path IS NOT NULL
`

type GetSessionTranscriptPathsBeforeRow struct {
	ID                   string         `json:"id"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
}

func (q *Queries) GetSessionTranscriptPathsBefore(ctx context.Context, createdAt string) ([]GetSessionTranscriptPathsBeforeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTranscriptPathsBefore, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionTranscriptPathsBeforeRow{}
	for rows.Next() {
		var i GetSessionTranscriptPathsBeforeRow
		if err := rows.Scan(&i.ID, &i.TranscriptStoredPath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionTranscriptPathsByExperiment = `-- name: GetSessionTranscriptPathsByExperiment :many
SELECT id, transcript_stored_path FROM sessions WHERE experiment_id = ? AND transcript_stored_path IS NOT NULL
`

type GetSessionTranscriptPathsByExperimentRow struct {
	ID                   string         `json:"id"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
}

func (q *Queries) GetSessionTranscriptPathsByExperiment(ctx context.Context, experimentID sql.NullString) ([]GetSessionTranscriptPathsByExperimentRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTranscriptPathsByExperiment, experimentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionTranscriptPathsByExperimentRow{}
	for rows.Next() {
		var i GetSessionTranscriptPathsByExperimentRow
		if err := rows.Scan(&i.ID, &i.TranscriptStoredPath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionTranscriptPathsByProject = `-- name: GetSessionTranscriptPathsByProject :many
SELECT id, transcript_stored_path FROM sessions WHERE project_id = ? AND transcript_stored_path IS NOT NULL
`

type GetSessionTranscriptPathsByProjectRow struct {
	ID                   string         `json:"id"`
	TranscriptStoredPath sql.NullString `json:"transcript_stored_path"`
}

func (q *Queries) GetSessionTranscriptPathsByProject(ctx context.Context, projectID string) ([]GetSessionTranscriptPathsByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getSessionTranscriptPathsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionTranscriptPathsByProjectRow{}
	for rows.Next() {
		var i GetSessionTranscriptPathsByProjectRow
		if err := rows.Scan(&i.ID, &i.TranscriptStoredPath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at FROM sessions
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListSessions(ctx context.Context, limit int64) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.TranscriptPath,
			&i.TranscriptStoredPath,
			&i.Cwd,
			&i.PermissionMode,
			&i.ExitReason,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByExperiment = `-- name: ListSessionsByExperiment :many
SELECT id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at FROM sessions
WHERE experiment_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListSessionsByExperimentParams struct {
	ExperimentID sql.NullString `json:"experiment_id"`
	Limit        int64          `json:"limit"`
}

func (q *Queries) ListSessionsByExperiment(ctx context.Context, arg ListSessionsByExperimentParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsByExperiment, arg.ExperimentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.TranscriptPath,
			&i.TranscriptStoredPath,
			&i.Cwd,
			&i.PermissionMode,
			&i.ExitReason,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByProject = `-- name: ListSessionsByProject :many
SELECT id, project_id, experiment_id, transcript_path, transcript_stored_path, cwd, permission_mode, exit_reason, started_at, ended_at, duration_seconds, created_at FROM sessions
WHERE project_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListSessionsByProjectParams struct {
	ProjectID string `json:"project_id"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) ListSessionsByProject(ctx context.Context, arg ListSessionsByProjectParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsByProject, arg.ProjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.TranscriptPath,
			&i.TranscriptStoredPath,
			&i.Cwd,
			&i.PermissionMode,
			&i.ExitReason,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsWithMetrics = `-- name: ListSessionsWithMetrics :many
SELECT
    s.id, s.project_id, s.experiment_id, s.cwd, s.permission_mode, s.exit_reason, s.created_at,
    s.started_at, s.ended_at, s.duration_seconds,
    COALESCE(m.turn_count, 0) as turn_count,
    COALESCE(m.token_input, 0) + COALESCE(m.token_output, 0) as total_tokens,
    m.cost_estimate_usd
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
ORDER BY s.created_at DESC
LIMIT ?
`

type ListSessionsWithMetricsRow struct {
	ID              string          `json:"id"`
	ProjectID       string          `json:"project_id"`
	ExperimentID    sql.NullString  `json:"experiment_id"`
	Cwd             string          `json:"cwd"`
	PermissionMode  string          `json:"permission_mode"`
	ExitReason      string          `json:"exit_reason"`
	CreatedAt       string          `json:"created_at"`
	StartedAt       sql.NullString  `json:"started_at"`
	EndedAt         sql.NullString  `json:"ended_at"`
	DurationSeconds sql.NullInt64   `json:"duration_seconds"`
	TurnCount       int64           `json:"turn_count"`
	TotalTokens     int64           `json:"total_tokens"`
	CostEstimateUsd sql.NullFloat64 `json:"cost_estimate_usd"`
}

func (q *Queries) ListSessionsWithMetrics(ctx context.Context, limit int64) ([]ListSessionsWithMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsWithMetrics, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsWithMetricsRow{}
	for rows.Next() {
		var i ListSessionsWithMetricsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.Cwd,
			&i.PermissionMode,
			&i.ExitReason,
			&i.CreatedAt,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.TurnCount,
			&i.TotalTokens,
			&i.CostEstimateUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsWithMetricsByExperiment = `-- name: ListSessionsWithMetricsByExperiment :many
SELECT
    s.id, s.project_id, s.experiment_id, s.cwd, s.permission_mode, s.exit_reason, s.created_at,
    s.started_at, s.ended_at, s.duration_seconds,
    COALESCE(m.turn_count, 0) as turn_count,
    COALESCE(m.token_input, 0) + COALESCE(m.token_output, 0) as total_tokens,
    m.cost_estimate_usd
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
WHERE s.experiment_id = ?
ORDER BY s.created_at DESC
LIMIT ?
`

type ListSessionsWithMetricsByExperimentParams struct {
	ExperimentID sql.NullString `json:"experiment_id"`
	Limit        int64          `json:"limit"`
}

type ListSessionsWithMetricsByExperimentRow struct {
	ID              string          `json:"id"`
	ProjectID       string          `json:"project_id"`
	ExperimentID    sql.NullString  `json:"experiment_id"`
	Cwd             string          `json:"cwd"`
	PermissionMode  string          `json:"permission_mode"`
	ExitReason      string          `json:"exit_reason"`
	CreatedAt       string          `json:"created_at"`
	StartedAt       sql.NullString  `json:"started_at"`
	EndedAt         sql.NullString  `json:"ended_at"`
	DurationSeconds sql.NullInt64   `json:"duration_seconds"`
	TurnCount       int64           `json:"turn_count"`
	TotalTokens     int64           `json:"total_tokens"`
	CostEstimateUsd sql.NullFloat64 `json:"cost_estimate_usd"`
}

func (q *Queries) ListSessionsWithMetricsByExperiment(ctx context.Context, arg ListSessionsWithMetricsByExperimentParams) ([]ListSessionsWithMetricsByExperimentRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsWithMetricsByExperiment, arg.ExperimentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsWithMetricsByExperimentRow{}
	for rows.Next() {
		var i ListSessionsWithMetricsByExperimentRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.Cwd,
			&i.PermissionMode,
			&i.ExitReason,
			&i.CreatedAt,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.TurnCount,
			&i.TotalTokens,
			&i.CostEstimateUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsWithMetricsFull = `-- name: ListSessionsWithMetricsFull :many
SELECT
    s.id, s.project_id, s.experiment_id, s.exit_reason, s.created_at,
    s.duration_seconds,
    COALESCE(m.turn_count, 0) as turn_count,
    COALESCE(m.token_input, 0) + COALESCE(m.token_output, 0) as total_tokens,
    m.cost_estimate_usd,
    m.model_id,
    (SELECT COUNT(*) FROM session_subagents sa WHERE sa.session_id = s.id) as subagent_count
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
ORDER BY s.created_at DESC
LIMIT ?
`

type ListSessionsWithMetricsFullRow struct {
	ID              string          `json:"id"`
	ProjectID       string          `json:"project_id"`
	ExperimentID    sql.NullString  `json:"experiment_id"`
	ExitReason      string          `json:"exit_reason"`
	CreatedAt       string          `json:"created_at"`
	DurationSeconds sql.NullInt64   `json:"duration_seconds"`
	TurnCount       int64           `json:"turn_count"`
	TotalTokens     int64           `json:"total_tokens"`
	CostEstimateUsd sql.NullFloat64 `json:"cost_estimate_usd"`
	ModelID         sql.NullString  `json:"model_id"`
	SubagentCount   int64           `json:"subagent_count"`
}

func (q *Queries) ListSessionsWithMetricsFull(ctx context.Context, limit int64) ([]ListSessionsWithMetricsFullRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsWithMetricsFull, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsWithMetricsFullRow{}
	for rows.Next() {
		var i ListSessionsWithMetricsFullRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.ExitReason,
			&i.CreatedAt,
			&i.DurationSeconds,
			&i.TurnCount,
			&i.TotalTokens,
			&i.CostEstimateUsd,
			&i.ModelID,
			&i.SubagentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsWithMetricsFullByExperiment = `-- name: ListSessionsWithMetricsFullByExperiment :many
SELECT
    s.id, s.project_id, s.experiment_id, s.exit_reason, s.created_at,
    s.duration_seconds,
    COALESCE(m.turn_count, 0) as turn_count,
    COALESCE(m.token_input, 0) + COALESCE(m.token_output, 0) as total_tokens,
    m.cost_estimate_usd,
    m.model_id,
    (SELECT COUNT(*) FROM session_subagents sa WHERE sa.session_id = s.id) as subagent_count
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
WHERE s.experiment_id = ?
ORDER BY s.created_at DESC
LIMIT ?
`

type ListSessionsWithMetricsFullByExperimentParams struct {
	ExperimentID sql.NullString `json:"experiment_id"`
	Limit        int64          `json:"limit"`
}

type ListSessionsWithMetricsFullByExperimentRow struct {
	ID              string          `json:"id"`
	ProjectID       string          `json:"project_id"`
	ExperimentID    sql.NullString  `json:"experiment_id"`
	ExitReason      string          `json:"exit_reason"`
	CreatedAt       string          `json:"created_at"`
	DurationSeconds sql.NullInt64   `json:"duration_seconds"`
	TurnCount       int64           `json:"turn_count"`
	TotalTokens     int64           `json:"total_tokens"`
	CostEstimateUsd sql.NullFloat64 `json:"cost_estimate_usd"`
	ModelID         sql.NullString  `json:"model_id"`
	SubagentCount   int64           `json:"subagent_count"`
}

func (q *Queries) ListSessionsWithMetricsFullByExperiment(ctx context.Context, arg ListSessionsWithMetricsFullByExperimentParams) ([]ListSessionsWithMetricsFullByExperimentRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsWithMetricsFullByExperiment, arg.ExperimentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsWithMetricsFullByExperimentRow{}
	for rows.Next() {
		var i ListSessionsWithMetricsFullByExperimentRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.ExitReason,
			&i.CreatedAt,
			&i.DurationSeconds,
			&i.TurnCount,
			&i.TotalTokens,
			&i.CostEstimateUsd,
			&i.ModelID,
			&i.SubagentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsWithMetricsFullByProject = `-- name: ListSessionsWithMetricsFullByProject :many
SELECT
    s.id, s.project_id, s.experiment_id, s.exit_reason, s.created_at,
    s.duration_seconds,
    COALESCE(m.turn_count, 0) as turn_count,
    COALESCE(m.token_input, 0) + COALESCE(m.token_output, 0) as total_tokens,
    m.cost_estimate_usd,
    m.model_id,
    (SELECT COUNT(*) FROM session_subagents sa WHERE sa.session_id = s.id) as subagent_count
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
WHERE s.project_id = ?
ORDER BY s.created_at DESC
LIMIT ?
`

type ListSessionsWithMetricsFullByProjectParams struct {
	ProjectID string `json:"project_id"`
	Limit     int64  `json:"limit"`
}

type ListSessionsWithMetricsFullByProjectRow struct {
	ID              string          `json:"id"`
	ProjectID       string          `json:"project_id"`
	ExperimentID    sql.NullString  `json:"experiment_id"`
	ExitReason      string          `json:"exit_reason"`
	CreatedAt       string          `json:"created_at"`
	DurationSeconds sql.NullInt64   `json:"duration_seconds"`
	TurnCount       int64           `json:"turn_count"`
	TotalTokens     int64           `json:"total_tokens"`
	CostEstimateUsd sql.NullFloat64 `json:"cost_estimate_usd"`
	ModelID         sql.NullString  `json:"model_id"`
	SubagentCount   int64           `json:"subagent_count"`
}

func (q *Queries) ListSessionsWithMetricsFullByProject(ctx context.Context, arg ListSessionsWithMetricsFullByProjectParams) ([]ListSessionsWithMetricsFullByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listSessionsWithMetricsFullByProject, arg.ProjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSessionsWithMetricsFullByProjectRow{}
	for rows.Next() {
		var i ListSessionsWithMetricsFullByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ExperimentID,
			&i.ExitReason,
			&i.CreatedAt,
			&i.DurationSeconds,
			&i.TurnCount,
			&i.TotalTokens,
			&i.CostEstimateUsd,
			&i.ModelID,
			&i.SubagentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
