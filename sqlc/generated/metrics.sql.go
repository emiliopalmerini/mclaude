// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: metrics.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createSessionCommand = `-- name: CreateSessionCommand :exec
INSERT INTO session_commands (session_id, command, exit_code, executed_at)
VALUES (?, ?, ?, ?)
`

type CreateSessionCommandParams struct {
	SessionID  string         `json:"session_id"`
	Command    string         `json:"command"`
	ExitCode   sql.NullInt64  `json:"exit_code"`
	ExecutedAt sql.NullString `json:"executed_at"`
}

func (q *Queries) CreateSessionCommand(ctx context.Context, arg CreateSessionCommandParams) error {
	_, err := q.db.ExecContext(ctx, createSessionCommand,
		arg.SessionID,
		arg.Command,
		arg.ExitCode,
		arg.ExecutedAt,
	)
	return err
}

const createSessionFile = `-- name: CreateSessionFile :exec
INSERT INTO session_files (session_id, file_path, operation, operation_count)
VALUES (?, ?, ?, ?)
ON CONFLICT (session_id, file_path, operation) DO UPDATE SET
    operation_count = operation_count + excluded.operation_count
`

type CreateSessionFileParams struct {
	SessionID      string `json:"session_id"`
	FilePath       string `json:"file_path"`
	Operation      string `json:"operation"`
	OperationCount int64  `json:"operation_count"`
}

func (q *Queries) CreateSessionFile(ctx context.Context, arg CreateSessionFileParams) error {
	_, err := q.db.ExecContext(ctx, createSessionFile,
		arg.SessionID,
		arg.FilePath,
		arg.Operation,
		arg.OperationCount,
	)
	return err
}

const createSessionMetrics = `-- name: CreateSessionMetrics :exec
INSERT OR REPLACE INTO session_metrics (session_id, message_count_user, message_count_assistant, turn_count, token_input, token_output, token_cache_read, token_cache_write, cost_estimate_usd, error_count)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSessionMetricsParams struct {
	SessionID             string          `json:"session_id"`
	MessageCountUser      int64           `json:"message_count_user"`
	MessageCountAssistant int64           `json:"message_count_assistant"`
	TurnCount             int64           `json:"turn_count"`
	TokenInput            int64           `json:"token_input"`
	TokenOutput           int64           `json:"token_output"`
	TokenCacheRead        int64           `json:"token_cache_read"`
	TokenCacheWrite       int64           `json:"token_cache_write"`
	CostEstimateUsd       sql.NullFloat64 `json:"cost_estimate_usd"`
	ErrorCount            int64           `json:"error_count"`
}

func (q *Queries) CreateSessionMetrics(ctx context.Context, arg CreateSessionMetricsParams) error {
	_, err := q.db.ExecContext(ctx, createSessionMetrics,
		arg.SessionID,
		arg.MessageCountUser,
		arg.MessageCountAssistant,
		arg.TurnCount,
		arg.TokenInput,
		arg.TokenOutput,
		arg.TokenCacheRead,
		arg.TokenCacheWrite,
		arg.CostEstimateUsd,
		arg.ErrorCount,
	)
	return err
}

const createSessionTool = `-- name: CreateSessionTool :exec
INSERT INTO session_tools (session_id, tool_name, invocation_count, total_duration_ms, error_count)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT (session_id, tool_name) DO UPDATE SET
    invocation_count = invocation_count + excluded.invocation_count,
    error_count = error_count + excluded.error_count
`

type CreateSessionToolParams struct {
	SessionID       string        `json:"session_id"`
	ToolName        string        `json:"tool_name"`
	InvocationCount int64         `json:"invocation_count"`
	TotalDurationMs sql.NullInt64 `json:"total_duration_ms"`
	ErrorCount      int64         `json:"error_count"`
}

func (q *Queries) CreateSessionTool(ctx context.Context, arg CreateSessionToolParams) error {
	_, err := q.db.ExecContext(ctx, createSessionTool,
		arg.SessionID,
		arg.ToolName,
		arg.InvocationCount,
		arg.TotalDurationMs,
		arg.ErrorCount,
	)
	return err
}

const getAggregateStats = `-- name: GetAggregateStats :one
SELECT
    COUNT(DISTINCT s.id) as session_count,
    COALESCE(SUM(m.message_count_user), 0) as total_user_messages,
    COALESCE(SUM(m.message_count_assistant), 0) as total_assistant_messages,
    COALESCE(SUM(m.turn_count), 0) as total_turns,
    COALESCE(SUM(m.token_input), 0) as total_token_input,
    COALESCE(SUM(m.token_output), 0) as total_token_output,
    COALESCE(SUM(m.token_cache_read), 0) as total_token_cache_read,
    COALESCE(SUM(m.token_cache_write), 0) as total_token_cache_write,
    COALESCE(SUM(m.cost_estimate_usd), 0) as total_cost_usd,
    COALESCE(SUM(m.error_count), 0) as total_errors
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
WHERE s.created_at >= ?
`

type GetAggregateStatsRow struct {
	SessionCount           int64       `json:"session_count"`
	TotalUserMessages      interface{} `json:"total_user_messages"`
	TotalAssistantMessages interface{} `json:"total_assistant_messages"`
	TotalTurns             interface{} `json:"total_turns"`
	TotalTokenInput        interface{} `json:"total_token_input"`
	TotalTokenOutput       interface{} `json:"total_token_output"`
	TotalTokenCacheRead    interface{} `json:"total_token_cache_read"`
	TotalTokenCacheWrite   interface{} `json:"total_token_cache_write"`
	TotalCostUsd           interface{} `json:"total_cost_usd"`
	TotalErrors            interface{} `json:"total_errors"`
}

func (q *Queries) GetAggregateStats(ctx context.Context, createdAt string) (GetAggregateStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAggregateStats, createdAt)
	var i GetAggregateStatsRow
	err := row.Scan(
		&i.SessionCount,
		&i.TotalUserMessages,
		&i.TotalAssistantMessages,
		&i.TotalTurns,
		&i.TotalTokenInput,
		&i.TotalTokenOutput,
		&i.TotalTokenCacheRead,
		&i.TotalTokenCacheWrite,
		&i.TotalCostUsd,
		&i.TotalErrors,
	)
	return i, err
}

const getAggregateStatsByExperiment = `-- name: GetAggregateStatsByExperiment :one
SELECT
    COUNT(DISTINCT s.id) as session_count,
    COALESCE(SUM(m.message_count_user), 0) as total_user_messages,
    COALESCE(SUM(m.message_count_assistant), 0) as total_assistant_messages,
    COALESCE(SUM(m.turn_count), 0) as total_turns,
    COALESCE(SUM(m.token_input), 0) as total_token_input,
    COALESCE(SUM(m.token_output), 0) as total_token_output,
    COALESCE(SUM(m.token_cache_read), 0) as total_token_cache_read,
    COALESCE(SUM(m.token_cache_write), 0) as total_token_cache_write,
    COALESCE(SUM(m.cost_estimate_usd), 0) as total_cost_usd,
    COALESCE(SUM(m.error_count), 0) as total_errors
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
WHERE s.experiment_id = ? AND s.created_at >= ?
`

type GetAggregateStatsByExperimentParams struct {
	ExperimentID sql.NullString `json:"experiment_id"`
	CreatedAt    string         `json:"created_at"`
}

type GetAggregateStatsByExperimentRow struct {
	SessionCount           int64       `json:"session_count"`
	TotalUserMessages      interface{} `json:"total_user_messages"`
	TotalAssistantMessages interface{} `json:"total_assistant_messages"`
	TotalTurns             interface{} `json:"total_turns"`
	TotalTokenInput        interface{} `json:"total_token_input"`
	TotalTokenOutput       interface{} `json:"total_token_output"`
	TotalTokenCacheRead    interface{} `json:"total_token_cache_read"`
	TotalTokenCacheWrite   interface{} `json:"total_token_cache_write"`
	TotalCostUsd           interface{} `json:"total_cost_usd"`
	TotalErrors            interface{} `json:"total_errors"`
}

func (q *Queries) GetAggregateStatsByExperiment(ctx context.Context, arg GetAggregateStatsByExperimentParams) (GetAggregateStatsByExperimentRow, error) {
	row := q.db.QueryRowContext(ctx, getAggregateStatsByExperiment, arg.ExperimentID, arg.CreatedAt)
	var i GetAggregateStatsByExperimentRow
	err := row.Scan(
		&i.SessionCount,
		&i.TotalUserMessages,
		&i.TotalAssistantMessages,
		&i.TotalTurns,
		&i.TotalTokenInput,
		&i.TotalTokenOutput,
		&i.TotalTokenCacheRead,
		&i.TotalTokenCacheWrite,
		&i.TotalCostUsd,
		&i.TotalErrors,
	)
	return i, err
}

const getAggregateStatsByProject = `-- name: GetAggregateStatsByProject :one
SELECT
    COUNT(DISTINCT s.id) as session_count,
    COALESCE(SUM(m.message_count_user), 0) as total_user_messages,
    COALESCE(SUM(m.message_count_assistant), 0) as total_assistant_messages,
    COALESCE(SUM(m.turn_count), 0) as total_turns,
    COALESCE(SUM(m.token_input), 0) as total_token_input,
    COALESCE(SUM(m.token_output), 0) as total_token_output,
    COALESCE(SUM(m.token_cache_read), 0) as total_token_cache_read,
    COALESCE(SUM(m.token_cache_write), 0) as total_token_cache_write,
    COALESCE(SUM(m.cost_estimate_usd), 0) as total_cost_usd,
    COALESCE(SUM(m.error_count), 0) as total_errors
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
WHERE s.project_id = ? AND s.created_at >= ?
`

type GetAggregateStatsByProjectParams struct {
	ProjectID string `json:"project_id"`
	CreatedAt string `json:"created_at"`
}

type GetAggregateStatsByProjectRow struct {
	SessionCount           int64       `json:"session_count"`
	TotalUserMessages      interface{} `json:"total_user_messages"`
	TotalAssistantMessages interface{} `json:"total_assistant_messages"`
	TotalTurns             interface{} `json:"total_turns"`
	TotalTokenInput        interface{} `json:"total_token_input"`
	TotalTokenOutput       interface{} `json:"total_token_output"`
	TotalTokenCacheRead    interface{} `json:"total_token_cache_read"`
	TotalTokenCacheWrite   interface{} `json:"total_token_cache_write"`
	TotalCostUsd           interface{} `json:"total_cost_usd"`
	TotalErrors            interface{} `json:"total_errors"`
}

func (q *Queries) GetAggregateStatsByProject(ctx context.Context, arg GetAggregateStatsByProjectParams) (GetAggregateStatsByProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getAggregateStatsByProject, arg.ProjectID, arg.CreatedAt)
	var i GetAggregateStatsByProjectRow
	err := row.Scan(
		&i.SessionCount,
		&i.TotalUserMessages,
		&i.TotalAssistantMessages,
		&i.TotalTurns,
		&i.TotalTokenInput,
		&i.TotalTokenOutput,
		&i.TotalTokenCacheRead,
		&i.TotalTokenCacheWrite,
		&i.TotalCostUsd,
		&i.TotalErrors,
	)
	return i, err
}

const getDailyStats = `-- name: GetDailyStats :many
SELECT
    DATE(s.created_at) as date,
    COUNT(DISTINCT s.id) as session_count,
    COALESCE(SUM(m.token_input + m.token_output), 0) as total_tokens,
    COALESCE(SUM(m.cost_estimate_usd), 0) as total_cost
FROM sessions s
LEFT JOIN session_metrics m ON s.id = m.session_id
WHERE s.created_at >= ?
GROUP BY DATE(s.created_at)
ORDER BY date ASC
LIMIT ?
`

type GetDailyStatsParams struct {
	CreatedAt string `json:"created_at"`
	Limit     int64  `json:"limit"`
}

type GetDailyStatsRow struct {
	Date         interface{} `json:"date"`
	SessionCount int64       `json:"session_count"`
	TotalTokens  interface{} `json:"total_tokens"`
	TotalCost    interface{} `json:"total_cost"`
}

func (q *Queries) GetDailyStats(ctx context.Context, arg GetDailyStatsParams) ([]GetDailyStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyStats, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyStatsRow{}
	for rows.Next() {
		var i GetDailyStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.SessionCount,
			&i.TotalTokens,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionMetricsBySessionID = `-- name: GetSessionMetricsBySessionID :one
SELECT session_id, message_count_user, message_count_assistant, turn_count, token_input, token_output, token_cache_read, token_cache_write, cost_estimate_usd, error_count FROM session_metrics WHERE session_id = ?
`

func (q *Queries) GetSessionMetricsBySessionID(ctx context.Context, sessionID string) (SessionMetric, error) {
	row := q.db.QueryRowContext(ctx, getSessionMetricsBySessionID, sessionID)
	var i SessionMetric
	err := row.Scan(
		&i.SessionID,
		&i.MessageCountUser,
		&i.MessageCountAssistant,
		&i.TurnCount,
		&i.TokenInput,
		&i.TokenOutput,
		&i.TokenCacheRead,
		&i.TokenCacheWrite,
		&i.CostEstimateUsd,
		&i.ErrorCount,
	)
	return i, err
}

const getStatsForAllExperiments = `-- name: GetStatsForAllExperiments :many
SELECT
    e.id as experiment_id,
    e.name as experiment_name,
    COUNT(DISTINCT s.id) as session_count,
    COALESCE(SUM(m.message_count_user), 0) as total_user_messages,
    COALESCE(SUM(m.message_count_assistant), 0) as total_assistant_messages,
    COALESCE(SUM(m.turn_count), 0) as total_turns,
    COALESCE(SUM(m.token_input), 0) as total_token_input,
    COALESCE(SUM(m.token_output), 0) as total_token_output,
    COALESCE(SUM(m.token_cache_read), 0) as total_token_cache_read,
    COALESCE(SUM(m.token_cache_write), 0) as total_token_cache_write,
    COALESCE(SUM(m.cost_estimate_usd), 0) as total_cost_usd,
    COALESCE(SUM(m.error_count), 0) as total_errors
FROM experiments e
LEFT JOIN sessions s ON s.experiment_id = e.id
LEFT JOIN session_metrics m ON s.id = m.session_id
GROUP BY e.id, e.name
ORDER BY e.created_at DESC
`

type GetStatsForAllExperimentsRow struct {
	ExperimentID           string      `json:"experiment_id"`
	ExperimentName         string      `json:"experiment_name"`
	SessionCount           int64       `json:"session_count"`
	TotalUserMessages      interface{} `json:"total_user_messages"`
	TotalAssistantMessages interface{} `json:"total_assistant_messages"`
	TotalTurns             interface{} `json:"total_turns"`
	TotalTokenInput        interface{} `json:"total_token_input"`
	TotalTokenOutput       interface{} `json:"total_token_output"`
	TotalTokenCacheRead    interface{} `json:"total_token_cache_read"`
	TotalTokenCacheWrite   interface{} `json:"total_token_cache_write"`
	TotalCostUsd           interface{} `json:"total_cost_usd"`
	TotalErrors            interface{} `json:"total_errors"`
}

func (q *Queries) GetStatsForAllExperiments(ctx context.Context) ([]GetStatsForAllExperimentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStatsForAllExperiments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStatsForAllExperimentsRow{}
	for rows.Next() {
		var i GetStatsForAllExperimentsRow
		if err := rows.Scan(
			&i.ExperimentID,
			&i.ExperimentName,
			&i.SessionCount,
			&i.TotalUserMessages,
			&i.TotalAssistantMessages,
			&i.TotalTurns,
			&i.TotalTokenInput,
			&i.TotalTokenOutput,
			&i.TotalTokenCacheRead,
			&i.TotalTokenCacheWrite,
			&i.TotalCostUsd,
			&i.TotalErrors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopToolsUsage = `-- name: GetTopToolsUsage :many
SELECT
    tool_name,
    SUM(invocation_count) as total_invocations,
    SUM(error_count) as total_errors
FROM session_tools st
JOIN sessions s ON st.session_id = s.id
WHERE s.created_at >= ?
GROUP BY tool_name
ORDER BY total_invocations DESC
LIMIT ?
`

type GetTopToolsUsageParams struct {
	CreatedAt string `json:"created_at"`
	Limit     int64  `json:"limit"`
}

type GetTopToolsUsageRow struct {
	ToolName         string          `json:"tool_name"`
	TotalInvocations sql.NullFloat64 `json:"total_invocations"`
	TotalErrors      sql.NullFloat64 `json:"total_errors"`
}

func (q *Queries) GetTopToolsUsage(ctx context.Context, arg GetTopToolsUsageParams) ([]GetTopToolsUsageRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopToolsUsage, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopToolsUsageRow{}
	for rows.Next() {
		var i GetTopToolsUsageRow
		if err := rows.Scan(&i.ToolName, &i.TotalInvocations, &i.TotalErrors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopToolsUsageByExperiment = `-- name: GetTopToolsUsageByExperiment :many
SELECT
    tool_name,
    SUM(invocation_count) as total_invocations,
    SUM(error_count) as total_errors
FROM session_tools st
JOIN sessions s ON st.session_id = s.id
WHERE s.experiment_id = ?
GROUP BY tool_name
ORDER BY total_invocations DESC
LIMIT ?
`

type GetTopToolsUsageByExperimentParams struct {
	ExperimentID sql.NullString `json:"experiment_id"`
	Limit        int64          `json:"limit"`
}

type GetTopToolsUsageByExperimentRow struct {
	ToolName         string          `json:"tool_name"`
	TotalInvocations sql.NullFloat64 `json:"total_invocations"`
	TotalErrors      sql.NullFloat64 `json:"total_errors"`
}

func (q *Queries) GetTopToolsUsageByExperiment(ctx context.Context, arg GetTopToolsUsageByExperimentParams) ([]GetTopToolsUsageByExperimentRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopToolsUsageByExperiment, arg.ExperimentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopToolsUsageByExperimentRow{}
	for rows.Next() {
		var i GetTopToolsUsageByExperimentRow
		if err := rows.Scan(&i.ToolName, &i.TotalInvocations, &i.TotalErrors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionCommandsBySessionID = `-- name: ListSessionCommandsBySessionID :many
SELECT id, session_id, command, exit_code, executed_at FROM session_commands WHERE session_id = ? ORDER BY id ASC
`

func (q *Queries) ListSessionCommandsBySessionID(ctx context.Context, sessionID string) ([]SessionCommand, error) {
	rows, err := q.db.QueryContext(ctx, listSessionCommandsBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionCommand{}
	for rows.Next() {
		var i SessionCommand
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Command,
			&i.ExitCode,
			&i.ExecutedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionFilesBySessionID = `-- name: ListSessionFilesBySessionID :many
SELECT id, session_id, file_path, operation, operation_count FROM session_files WHERE session_id = ? ORDER BY operation_count DESC
`

func (q *Queries) ListSessionFilesBySessionID(ctx context.Context, sessionID string) ([]SessionFile, error) {
	rows, err := q.db.QueryContext(ctx, listSessionFilesBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionFile{}
	for rows.Next() {
		var i SessionFile
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.FilePath,
			&i.Operation,
			&i.OperationCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionToolsBySessionID = `-- name: ListSessionToolsBySessionID :many
SELECT id, session_id, tool_name, invocation_count, total_duration_ms, error_count FROM session_tools WHERE session_id = ? ORDER BY invocation_count DESC
`

func (q *Queries) ListSessionToolsBySessionID(ctx context.Context, sessionID string) ([]SessionTool, error) {
	rows, err := q.db.QueryContext(ctx, listSessionToolsBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionTool{}
	for rows.Next() {
		var i SessionTool
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.ToolName,
			&i.InvocationCount,
			&i.TotalDurationMs,
			&i.ErrorCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
