// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createUsageLimit = `-- name: CreateUsageLimit :exec
INSERT INTO usage_limits (id, limit_value, warn_threshold, enabled, updated_at)
VALUES (?, ?, ?, ?, datetime('now'))
ON CONFLICT (id) DO UPDATE SET
    limit_value = excluded.limit_value,
    warn_threshold = excluded.warn_threshold,
    enabled = excluded.enabled,
    updated_at = datetime('now')
`

type CreateUsageLimitParams struct {
	ID            string          `json:"id"`
	LimitValue    float64         `json:"limit_value"`
	WarnThreshold sql.NullFloat64 `json:"warn_threshold"`
	Enabled       int64           `json:"enabled"`
}

func (q *Queries) CreateUsageLimit(ctx context.Context, arg CreateUsageLimitParams) error {
	_, err := q.db.ExecContext(ctx, createUsageLimit,
		arg.ID,
		arg.LimitValue,
		arg.WarnThreshold,
		arg.Enabled,
	)
	return err
}

const createUsageMetric = `-- name: CreateUsageMetric :exec
INSERT INTO usage_metrics (metric_name, value, attributes, recorded_at)
VALUES (?, ?, ?, ?)
`

type CreateUsageMetricParams struct {
	MetricName string         `json:"metric_name"`
	Value      float64        `json:"value"`
	Attributes sql.NullString `json:"attributes"`
	RecordedAt string         `json:"recorded_at"`
}

func (q *Queries) CreateUsageMetric(ctx context.Context, arg CreateUsageMetricParams) error {
	_, err := q.db.ExecContext(ctx, createUsageMetric,
		arg.MetricName,
		arg.Value,
		arg.Attributes,
		arg.RecordedAt,
	)
	return err
}

const deleteUsageLimit = `-- name: DeleteUsageLimit :exec
DELETE FROM usage_limits WHERE id = ?
`

func (q *Queries) DeleteUsageLimit(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUsageLimit, id)
	return err
}

const deleteUsageMetricsBefore = `-- name: DeleteUsageMetricsBefore :execrows
DELETE FROM usage_metrics WHERE recorded_at < ?
`

func (q *Queries) DeleteUsageMetricsBefore(ctx context.Context, recordedAt string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteUsageMetricsBefore, recordedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getDailyUsageSummary = `-- name: GetDailyUsageSummary :one
SELECT
    CAST(COALESCE(SUM(CASE WHEN metric_name = 'claude_code.token.usage' THEN value ELSE 0 END), 0) AS REAL) as total_tokens,
    CAST(COALESCE(SUM(CASE WHEN metric_name = 'claude_code.cost.usage' THEN value ELSE 0 END), 0) AS REAL) as total_cost
FROM usage_metrics
WHERE recorded_at >= date('now', 'start of day')
`

type GetDailyUsageSummaryRow struct {
	TotalTokens float64 `json:"total_tokens"`
	TotalCost   float64 `json:"total_cost"`
}

func (q *Queries) GetDailyUsageSummary(ctx context.Context) (GetDailyUsageSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getDailyUsageSummary)
	var i GetDailyUsageSummaryRow
	err := row.Scan(&i.TotalTokens, &i.TotalCost)
	return i, err
}

const getPlanConfig = `-- name: GetPlanConfig :one
SELECT id, plan_type, window_hours, learned_token_limit, learned_at, created_at, updated_at FROM plan_config WHERE id = 1
`

func (q *Queries) GetPlanConfig(ctx context.Context) (PlanConfig, error) {
	row := q.db.QueryRowContext(ctx, getPlanConfig)
	var i PlanConfig
	err := row.Scan(
		&i.ID,
		&i.PlanType,
		&i.WindowHours,
		&i.LearnedTokenLimit,
		&i.LearnedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRollingWindowUsage = `-- name: GetRollingWindowUsage :one
SELECT
    CAST(COALESCE(SUM(CASE WHEN metric_name = 'claude_code.token.usage' THEN value ELSE 0 END), 0) AS REAL) as total_tokens,
    CAST(COALESCE(SUM(CASE WHEN metric_name = 'claude_code.cost.usage' THEN value ELSE 0 END), 0) AS REAL) as total_cost
FROM usage_metrics
WHERE recorded_at >= datetime('now', ? || ' hours')
`

type GetRollingWindowUsageRow struct {
	TotalTokens float64 `json:"total_tokens"`
	TotalCost   float64 `json:"total_cost"`
}

func (q *Queries) GetRollingWindowUsage(ctx context.Context, dollar_1 sql.NullString) (GetRollingWindowUsageRow, error) {
	row := q.db.QueryRowContext(ctx, getRollingWindowUsage, dollar_1)
	var i GetRollingWindowUsageRow
	err := row.Scan(&i.TotalTokens, &i.TotalCost)
	return i, err
}

const getTokenUsageByType = `-- name: GetTokenUsageByType :many
SELECT
    json_extract(attributes, '$.type') as token_type,
    SUM(value) as total
FROM usage_metrics
WHERE metric_name = 'claude_code.token.usage'
  AND recorded_at >= ?
GROUP BY token_type
`

type GetTokenUsageByTypeRow struct {
	TokenType interface{}     `json:"token_type"`
	Total     sql.NullFloat64 `json:"total"`
}

func (q *Queries) GetTokenUsageByType(ctx context.Context, recordedAt string) ([]GetTokenUsageByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTokenUsageByType, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTokenUsageByTypeRow{}
	for rows.Next() {
		var i GetTokenUsageByTypeRow
		if err := rows.Scan(&i.TokenType, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageForPeriod = `-- name: GetUsageForPeriod :many
SELECT
    metric_name,
    SUM(value) as total_value
FROM usage_metrics
WHERE recorded_at >= ? AND recorded_at < ?
GROUP BY metric_name
`

type GetUsageForPeriodParams struct {
	RecordedAt   string `json:"recorded_at"`
	RecordedAt_2 string `json:"recorded_at_2"`
}

type GetUsageForPeriodRow struct {
	MetricName string          `json:"metric_name"`
	TotalValue sql.NullFloat64 `json:"total_value"`
}

func (q *Queries) GetUsageForPeriod(ctx context.Context, arg GetUsageForPeriodParams) ([]GetUsageForPeriodRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsageForPeriod, arg.RecordedAt, arg.RecordedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageForPeriodRow{}
	for rows.Next() {
		var i GetUsageForPeriodRow
		if err := rows.Scan(&i.MetricName, &i.TotalValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageLimit = `-- name: GetUsageLimit :one
SELECT id, limit_value, warn_threshold, enabled, created_at, updated_at FROM usage_limits WHERE id = ?
`

func (q *Queries) GetUsageLimit(ctx context.Context, id string) (UsageLimit, error) {
	row := q.db.QueryRowContext(ctx, getUsageLimit, id)
	var i UsageLimit
	err := row.Scan(
		&i.ID,
		&i.LimitValue,
		&i.WarnThreshold,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWeeklyUsageSummary = `-- name: GetWeeklyUsageSummary :one
SELECT
    CAST(COALESCE(SUM(CASE WHEN metric_name = 'claude_code.token.usage' THEN value ELSE 0 END), 0) AS REAL) as total_tokens,
    CAST(COALESCE(SUM(CASE WHEN metric_name = 'claude_code.cost.usage' THEN value ELSE 0 END), 0) AS REAL) as total_cost
FROM usage_metrics
WHERE recorded_at >= date('now', 'weekday 0', '-7 days')
`

type GetWeeklyUsageSummaryRow struct {
	TotalTokens float64 `json:"total_tokens"`
	TotalCost   float64 `json:"total_cost"`
}

func (q *Queries) GetWeeklyUsageSummary(ctx context.Context) (GetWeeklyUsageSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getWeeklyUsageSummary)
	var i GetWeeklyUsageSummaryRow
	err := row.Scan(&i.TotalTokens, &i.TotalCost)
	return i, err
}

const listUsageLimits = `-- name: ListUsageLimits :many
SELECT id, limit_value, warn_threshold, enabled, created_at, updated_at FROM usage_limits ORDER BY id
`

func (q *Queries) ListUsageLimits(ctx context.Context) ([]UsageLimit, error) {
	rows, err := q.db.QueryContext(ctx, listUsageLimits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageLimit{}
	for rows.Next() {
		var i UsageLimit
		if err := rows.Scan(
			&i.ID,
			&i.LimitValue,
			&i.WarnThreshold,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLearnedLimit = `-- name: UpdateLearnedLimit :exec
UPDATE plan_config
SET learned_token_limit = ?, learned_at = datetime('now'), updated_at = datetime('now')
WHERE id = 1
`

func (q *Queries) UpdateLearnedLimit(ctx context.Context, learnedTokenLimit sql.NullFloat64) error {
	_, err := q.db.ExecContext(ctx, updateLearnedLimit, learnedTokenLimit)
	return err
}

const upsertPlanConfig = `-- name: UpsertPlanConfig :exec
INSERT INTO plan_config (id, plan_type, window_hours, learned_token_limit, learned_at, updated_at)
VALUES (1, ?, ?, ?, ?, datetime('now'))
ON CONFLICT (id) DO UPDATE SET
    plan_type = excluded.plan_type,
    window_hours = excluded.window_hours,
    learned_token_limit = excluded.learned_token_limit,
    learned_at = excluded.learned_at,
    updated_at = datetime('now')
`

type UpsertPlanConfigParams struct {
	PlanType          string          `json:"plan_type"`
	WindowHours       int64           `json:"window_hours"`
	LearnedTokenLimit sql.NullFloat64 `json:"learned_token_limit"`
	LearnedAt         sql.NullString  `json:"learned_at"`
}

func (q *Queries) UpsertPlanConfig(ctx context.Context, arg UpsertPlanConfigParams) error {
	_, err := q.db.ExecContext(ctx, upsertPlanConfig,
		arg.PlanType,
		arg.WindowHours,
		arg.LearnedTokenLimit,
		arg.LearnedAt,
	)
	return err
}
